{"expireTime":9007200877354307000,"key":"transformer-remark-markdown-html-ast-668fd5f2094cab58147a7edba5afca44-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"참고도서: ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":7,"offset":7}}},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne","position":{"start":{"line":2,"column":8,"offset":8},"end":{"line":2,"column":90,"offset":90}}}],"position":{"start":{"line":2,"column":7,"offset":7},"end":{"line":2,"column":91,"offset":91}}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":91,"offset":91}}},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"메인-메모리","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%EB%A9%94%EC%9D%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC","aria-label":"메인 메모리 permalink","class":"anchor before"},"children":[{"type":"raw","value":"<svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>"}]},{"type":"text","value":"메인 메모리","position":{"start":{"line":4,"column":4,"offset":96},"end":{"line":4,"column":10,"offset":102}}}],"position":{"start":{"line":4,"column":1,"offset":93},"end":{"line":4,"column":10,"offset":102}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"컴퓨터 시스템 안에서 CPU가 직접적으로 접근할 수 있는 저장장치는 각 코어 안에 내장된 캐시와 메인메모리 뿐이다. 메인메모리 없는 컴퓨터는 시체나 다름없는데(사실 다른 주요장치들도 없으면 안되지만), 이 메인메모리가 어떻게 구성되고 관리되는지 공부해보자","position":{"start":{"line":6,"column":1,"offset":104},"end":{"line":6,"column":143,"offset":246}}}],"position":{"start":{"line":6,"column":1,"offset":104},"end":{"line":6,"column":143,"offset":246}}},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"기준-레지스터와-상한-레지스터","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%EA%B8%B0%EC%A4%80-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0%EC%99%80-%EC%83%81%ED%95%9C-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0","aria-label":"기준 레지스터와 상한 레지스터 permalink","class":"anchor before"},"children":[{"type":"raw","value":"<svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>"}]},{"type":"text","value":"기준 레지스터와 상한 레지스터","position":{"start":{"line":8,"column":4,"offset":251},"end":{"line":8,"column":20,"offset":267}}}],"position":{"start":{"line":8,"column":1,"offset":248},"end":{"line":8,"column":20,"offset":267}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"운영체제와 프로세스는 모두 메모리에 적재되어서 실행되어진다. 따라서 메모리 내에서 영역을 정확하게 구분하는 것이 필수적으로 요구된다. 운영체제는 그렇다 치고, 만약 어떤 프로세스가 메모리 여기저기에 데이터를 쓰고 다닌다면… 상상만해도 끔찍쓰..","position":{"start":{"line":10,"column":1,"offset":269},"end":{"line":10,"column":139,"offset":407}}}],"position":{"start":{"line":10,"column":1,"offset":269},"end":{"line":10,"column":139,"offset":407}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 각 프로세스마다 명확한 공간을 분리하기 위해서 ","position":{"start":{"line":12,"column":1,"offset":409},"end":{"line":12,"column":31,"offset":439}}},{"type":"raw","value":"<code class=\"language-text\">기준 레지스터(base register)</code>","position":{"start":{"line":12,"column":31,"offset":439},"end":{"line":12,"column":55,"offset":463}}},{"type":"text","value":" 와 ","position":{"start":{"line":12,"column":55,"offset":463},"end":{"line":12,"column":58,"offset":466}}},{"type":"raw","value":"<code class=\"language-text\">상한 레지스터(limit register)</code>","position":{"start":{"line":12,"column":58,"offset":466},"end":{"line":12,"column":83,"offset":491}}},{"type":"text","value":" 를 사용하게된다. 기준 레지스터는 어떤 프로세스가 시작되는 가장 첫 시작주소를 가지고, 상한 레지스터는 해당 프로세스가 최대로 사용할 공간을 가진다. 따라서 이 프로세스는 기준 주소부터 ","position":{"start":{"line":12,"column":83,"offset":491},"end":{"line":12,"column":188,"offset":596}}},{"type":"raw","value":"<code class=\"language-text\">기준+상한</code>","position":{"start":{"line":12,"column":188,"offset":596},"end":{"line":12,"column":195,"offset":603}}},{"type":"text","value":" 주소까지의 메모리 공간을 사용하고 보호받게 되는 것이다. 만약 어떤 프로세스의 연산이 다른 프로세스의 영역을 침범하게 된다면, 운영체제는 이 접근을 허용하지 않고 트랩을 통해서 동작을 정지시킨다.","position":{"start":{"line":12,"column":195,"offset":603},"end":{"line":12,"column":305,"offset":713}}}],"position":{"start":{"line":12,"column":1,"offset":409},"end":{"line":12,"column":305,"offset":713}}},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"논리-공간과-물리-주소공간","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%EB%85%BC%EB%A6%AC-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EB%AC%BC%EB%A6%AC-%EC%A3%BC%EC%86%8C%EA%B3%B5%EA%B0%84","aria-label":"논리 공간과 물리 주소공간 permalink","class":"anchor before"},"children":[{"type":"raw","value":"<svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>"}]},{"type":"text","value":"논리 공간과 물리 주소공간","position":{"start":{"line":14,"column":4,"offset":718},"end":{"line":14,"column":18,"offset":732}}}],"position":{"start":{"line":14,"column":1,"offset":715},"end":{"line":14,"column":18,"offset":732}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CPU가 연산을 진행하며 생성하는 주소는 메모리에서 사용하는 주소와 다르다. 우리는 CPU에서 생성되는 주소를 ","position":{"start":{"line":16,"column":1,"offset":734},"end":{"line":16,"column":63,"offset":796}}},{"type":"raw","value":"<code class=\"language-text\">논리 주소(Logical address)</code>","position":{"start":{"line":16,"column":63,"offset":796},"end":{"line":16,"column":87,"offset":820}}},{"type":"text","value":" 라고 하고, 메모리에서 사용하는 주소를 ","position":{"start":{"line":16,"column":87,"offset":820},"end":{"line":16,"column":110,"offset":843}}},{"type":"raw","value":"<code class=\"language-text\">물리 주소(Physical address)</code>","position":{"start":{"line":16,"column":110,"offset":843},"end":{"line":16,"column":135,"offset":868}}},{"type":"text","value":" 라고 한다. 이것은 CPU에서 생성된 주소로 메모리에 접근하면 원하는 결과를 얻을 수 없다는 것을 의미한다. 따라서 CPU와 메모리 사이에서 논리 주소를 물리 주소로 변환시켜주는 작업을 하는 장치가 필요하다.","position":{"start":{"line":16,"column":135,"offset":868},"end":{"line":16,"column":252,"offset":985}}}],"position":{"start":{"line":16,"column":1,"offset":734},"end":{"line":16,"column":252,"offset":985}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이 장치를 우리는 ","position":{"start":{"line":18,"column":1,"offset":987},"end":{"line":18,"column":11,"offset":997}}},{"type":"raw","value":"<code class=\"language-text\">메모리 관리 장치(MMU)</code>","position":{"start":{"line":18,"column":11,"offset":997},"end":{"line":18,"column":27,"offset":1013}}},{"type":"text","value":" 라고 부른다. MMU는 다양한 방법을 통해서 논리 주소를 물리 주소로 변환하는데, 가장 간단한 방법이 ","position":{"start":{"line":18,"column":27,"offset":1013},"end":{"line":18,"column":85,"offset":1071}}},{"type":"raw","value":"<code class=\"language-text\">재배치 레지스터(relocation register)</code>","position":{"start":{"line":18,"column":85,"offset":1071},"end":{"line":18,"column":116,"offset":1102}}},{"type":"text","value":"를 사용하는 것이다. 재배치 레지스터의 역할은 앞서 설명했던 기준 레지스터의 역할과 비슷하다. 이 레지스터는 각 프로세스의 어떤 특정한 값을 가지고 CPU에서 논리 주소가 들어올 때마다 이 값을 논리 주소에 더해서 물리 주소를 만들어낸다. 예를 들어, CPU에서 생성한 주소가 30 이고 재배치 레지스터의 값이 300 이라면, CPU는 메모리 주소 330번지에 있는 데이터에 접근하게 되는 것이다.","position":{"start":{"line":18,"column":116,"offset":1102},"end":{"line":18,"column":338,"offset":1324}}}],"position":{"start":{"line":18,"column":1,"offset":987},"end":{"line":18,"column":338,"offset":1324}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 논리 주소를 물리주소로 변환해서 CPU가 바로 메모리에 접근할 수 없게 하는 것의 이점은 메모리 내의 프로세스의 위치가 달라져도 CPU는 항상 같은 논리 주소로 해당 프로세스에 접근할 수 있다는 것이다.","position":{"start":{"line":20,"column":1,"offset":1326},"end":{"line":20,"column":118,"offset":1443}}}],"position":{"start":{"line":20,"column":1,"offset":1326},"end":{"line":20,"column":118,"offset":1443}}},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"메모리-할당","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9","aria-label":"메모리 할당 permalink","class":"anchor before"},"children":[{"type":"raw","value":"<svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>"}]},{"type":"text","value":"메모리 할당","position":{"start":{"line":22,"column":4,"offset":1448},"end":{"line":22,"column":10,"offset":1454}}}],"position":{"start":{"line":22,"column":1,"offset":1445},"end":{"line":22,"column":10,"offset":1454}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"프로그램이 프로세스가 되어 메모리에 적재될 때, 가장 간단한 방법은 ","position":{"start":{"line":24,"column":1,"offset":1456},"end":{"line":24,"column":39,"offset":1494}}},{"type":"raw","value":"<code class=\"language-text\">가변 파티션(Dynamic partitioning)</code>","position":{"start":{"line":24,"column":39,"offset":1494},"end":{"line":24,"column":69,"offset":1524}}},{"type":"text","value":" 이다. 단순하게 새로 메모리에 올라온 프로세스를 사용가능한 공간에 적재시키는 것이다. 이렇게 메모리를 관리하게 되면, 사용가능한 메모리 영역이 구분되게 되는데 이런 공간을 ","position":{"start":{"line":24,"column":69,"offset":1524},"end":{"line":24,"column":166,"offset":1621}}},{"type":"raw","value":"<code class=\"language-text\">hole</code>","position":{"start":{"line":24,"column":166,"offset":1621},"end":{"line":24,"column":172,"offset":1627}}},{"type":"text","value":"이라고 한다. 유의할 점은 hole이 단순하게 모든 사용가능한 공간의 합을 의미하지 않는다는 것이다. 만약 연속된 메모리 공간에 프로세스 1, 프로세스 2, 프로세스 3 이 적재되어 있을 때, 프로세스 2의 작업이 끝나고 메모리에세 제거 되면, 메모리에는 프로세스 1의 공간과 프로세스 3의 공간 사이에 있는 hole, 그리고 프로세스 3 이후의 있는 빈 공간들로 총 두 개의 hole이 존재하게 된다.","position":{"start":{"line":24,"column":172,"offset":1627},"end":{"line":24,"column":397,"offset":1852}}}],"position":{"start":{"line":24,"column":1,"offset":1456},"end":{"line":24,"column":397,"offset":1852}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"여기서 한가지 문제점이 발생한다. 프로세스가 계속해서 메모리에 적재되고 해제되다 보면 수많은 hole이 생겨날텐데, 새로 들어온 프로세스는 이들 중 어디에 적재시켜야 할까? 이 문제를 해결하기 위해 세 가지 방법이 제안된다.","position":{"start":{"line":26,"column":1,"offset":1854},"end":{"line":26,"column":126,"offset":1979}}}],"position":{"start":{"line":26,"column":1,"offset":1854},"end":{"line":26,"column":126,"offset":1979}}},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"raw","value":"<code class=\"language-text\">최초 적합(First-fit)</code>","position":{"start":{"line":28,"column":4,"offset":1984},"end":{"line":28,"column":22,"offset":2002}}},{"type":"text","value":": 메모리의 시작점 혹은 끝 지점부터 순서대로 탐색하면서, 새 프로세스를 적재할 수 있는 크기를 가진 hole이 등장하면 곧바로 프로세스를 적재시킨다.","position":{"start":{"line":28,"column":22,"offset":2002},"end":{"line":28,"column":106,"offset":2086}}}],"position":{"start":{"line":28,"column":1,"offset":1981},"end":{"line":28,"column":106,"offset":2086}}},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"raw","value":"<code class=\"language-text\">최적 적합(Best-fit)</code>","position":{"start":{"line":29,"column":4,"offset":2090},"end":{"line":29,"column":21,"offset":2107}}},{"type":"text","value":": 메모리에 있는 모든 hole을 다 확인해서 사용가능한 hole 중 새 프로세스와 크기가 가장 가까운 hole에 프로세스를 적재시킨다. 단점은 모든 hole들을 다 탐색해야하기 때문에 오버헤드가 발생하게 된다.","position":{"start":{"line":29,"column":21,"offset":2107},"end":{"line":29,"column":139,"offset":2225}}}],"position":{"start":{"line":29,"column":1,"offset":2087},"end":{"line":29,"column":139,"offset":2225}}},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"raw","value":"<code class=\"language-text\">최악 적합(Worst-fit)</code>","position":{"start":{"line":30,"column":4,"offset":2229},"end":{"line":30,"column":22,"offset":2247}}},{"type":"text","value":": 메모리에 있는 모든 hole을 다 확인해서 사용가능한 hole 중 크기가 가장 큰 hole에 프로세스를 적재한다. 이떄 프로세스를 적재하고 남은 크기는 다시 또 새로운 hole 이 된다. 이 방법 역시 메모리 내의 모든 hole을 다 검사해야하는 오버헤드가 발생한다.","position":{"start":{"line":30,"column":22,"offset":2247},"end":{"line":30,"column":173,"offset":2398}}}],"position":{"start":{"line":30,"column":1,"offset":2226},"end":{"line":30,"column":173,"offset":2398}}},{"type":"text","value":"\n"}],"position":{"start":{"line":28,"column":1,"offset":1981},"end":{"line":30,"column":173,"offset":2398}}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":31,"column":1,"offset":2399}}}}