{"expireTime":9007200877354307000,"key":"transformer-remark-markdown-html-c2ebb4e5a750ba8f77278d9ca2bae86e-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":"<p>참고도서: <em>Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne</em></p>\n<h2 id=\"2장---운영체제-구조\" style=\"position:relative;\"><a href=\"#2%EC%9E%A5---%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%AC%EC%A1%B0\" aria-label=\"2장   운영체제 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2장 - 운영체제 구조</h2>\n<p><strong>2.1 시스템 콜의 목적은 무엇인가?</strong></p>\n<ul>\n<li>운영체제에 의해 제공되는 시스템의 서비스를 사용할 수 있는 인터페이스를 제공하는 역할을 한다. 사용자 모드에서 발생하는 시스템 콜은 일반적으로 시스템 콜 인터페이스를 통해 커널모드로 사용모드를 전환하고 전달된 시스템콜의 종류에 따라 정해진 명령어들을 수행하게된다.</li>\n</ul>\n<p><strong>2.2 명령 인터프리터의 목적은 무엇인가? 통상 커널에 포함되지 않는 이유는 무엇인가?</strong></p>\n<ul>\n<li>명령 인터프리터는 사용자가 지정한 명령을 해석해서 그에 맞는 작업을 운영체제가 수행하도록 한다. 명령 인터프러터는 완전히 사용자를 위한 프로세스 이기 때문에 커널에 포함되지 않고 유저 모드에서 사용이 가능하도록 한다.</li>\n</ul>\n<p><strong>2.3 UNIX 시스템에서 새 프로세스를 시작하기 위해 명령 인터프리터나 셸에서 어떤 시스템 콜이 실행되어야 하는가?</strong></p>\n<ol>\n<li>셸에 실행 파일이 입력된다.</li>\n<li>셸이 <code class=\"language-text\">fork()</code> 시스템 콜을 사용해서 새로운 프로세스를 만든다.</li>\n<li>곧바로 <code class=\"language-text\">exec()</code> 시스템 콜을 사용해서 로더를 호출한다.</li>\n<li>호출된 로더는 입력된 프로그램의 이름을 가진 프로세스를 찾는다.</li>\n<li>찾은 프로세스를 새로 생성한 프로세스의 메모리 공간에 적재시킨다.</li>\n</ol>\n<p><strong>2.4 시스템 프로그램의 목적은 무엇인가?</strong></p>\n<ul>\n<li>시스템 프로그램은 컴퓨터 시스템이 시작되어서 종료될 때까지 계속 실행되면서 사용자가 필요로 하는 서비스들을 운영체제와 더불어 제공하는 역할을 한다.</li>\n</ul>\n<p><strong>2.5 시스템 설계시 계층화된 접근 방식의 주요 장점은 무엇인가? 단점은 무엇인가?</strong></p>\n<ol>\n<li>장점: Layered Approach 구조의 장점은 <code class=\"language-text\">디버깅과 구현의 편리함</code>에 있다. 각 계층은 자신과 자신의 하위 계층이 가진 서비스와 연산을 이용한다. 따라서 디버깅시에 문제가 있는 위치를 파악하기에 용이하다.</li>\n<li>사용자 프로그램이 어떤 서비스를 얻기 위해서 각 계층을 통과해야하기 때문에 이 과정에서 오버헤드가 발생한다.</li>\n</ol>\n<p><strong>2.6 운영체제에서 제공하는 5가지 서비스를 나열하고 각 서비스가 사용자에게 편의를 제공하는 방법을 설명하라. 사용자 수준 프로그램이 이러한 서비스를 제공할 수 없는 경우는 언제인가?</strong></p>\n<ol>\n<li><code class=\"language-text\">사용자 인터페이스</code>: 사용자가 여러 명령을 쉽게 사용할 수 있는 인터페이스를 제공한다. 특히 GUI는 사용자에게 시각적인 경험을 제공하면서 사용자의 사용성을 크게 높인다. 사용자 수준의 프로그램 역시 인터페이스를 제공하지만 이 인터페이스들은 결국 운영체제가 제공하는 인터페이스 위에서 동작한다.</li>\n<li><code class=\"language-text\">프로그램 수행</code>: 프로그램을 메모리에 적재하고 실행하는 것은 전적으로 운영체제의 일이다. 사용자 프로그램이 새로운 프로세스를 만들거나 프로세스를 중지시키는 것 역시 우리가 느끼기에는 사용자 수준의 프로그램이 하는 것 처럼 보이지만 결국 해당 프로그램이 만든 시스템 콜에 의해 프로그램의 상태가 운영체제에게 맡겨져 제어된다.</li>\n<li><code class=\"language-text\">입출력 연산</code>: I/O 역시 시스템 콜의 집합체이다. 운영체제의 서비스 없이는 불가능하다.</li>\n<li><code class=\"language-text\">파일 시스템 조작</code>: 파일에 관리와 조작도 운영체제에서 제공하는 기능이다. 특히 파일의 권한이나 접근 허용에 대한 부분은 운영체제가 담당하는 매우 중요한 일이다.</li>\n<li><code class=\"language-text\">통신</code>: 시스템 안에서 실행되고 프로세스들간의 통신도 운영체제의 역할이다.</li>\n</ol>"}