{"expireTime":9007200877354896000,"key":"transformer-remark-markdown-html-54e636c233547d9999526dc84e46020e-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":"<p>참고도서: <em>Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne</em></p>\n<p><strong>3.1 그림 3.30에 표시된 프로그램을 사용하여 LINE A에서 출력되는 내용을 설명하라</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n\n<span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    pid_t pid<span class=\"token punctuation\">;</span>\n    pid <span class=\"token operator\">=</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pid <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* child process */</span>\n        value <span class=\"token operator\">+=</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pid <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* parent process */</span>\n        <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"PARENT: value = %d\"</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* LINE A*/</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>위 프로그램을 실행하면 <code class=\"language-text\">fork()</code> 시스템 콜에 의해 새로운 프로세스가 하나 생성된다. 같은 내용을 가지고 있는 두 프로세스가 만들어지고 이때 부모 프로세스의 <code class=\"language-text\">pid</code> 값에 새로 생성된 프로세스의 process idetifier 가 저장되게 된다. 생성된 자녀 프로세스의 <code class=\"language-text\">pid</code> 값은 0이 되므로 두 프로세스는 각각 조건문의 다른 분기로 나누어져서 실행을 하게 된다. 먼저 부모 프로세스는 <code class=\"language-text\">else if</code> 문으로 진입하자마자 <code class=\"language-text\">wait()</code> 시스템콜을 통해서 자녀 프로세스가 끝날 때까지 대기하게 된다. 그리고 동시에 자녀 프로세스는 <code class=\"language-text\">if</code> 문 안으로 들어가서 <code class=\"language-text\">value</code> 의 값을 15 증가시킨다. 자녀 프로세스가 값을 증가시키고 종료되면, wait 시스템 콜에 의해 대기 중이던 부모 프로세스가 실행되고 부모 프로세스의 안에서 value 의 값은 5이기 때문에 LINE A는 <code class=\"language-text\">PARENT: value = 5</code> 를 출력하고 종료된다.</li>\n</ul>\n<p><strong>3.2 최초의 부모 프로세스를 포함하여 그림 3.31에 표시된 프로그램의 의해 몇 개의 프로세스가 생성되는가?</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">/* fork a child process */</span>\n<span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* fork another child process */</span>\n<span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* and fork another */</span>\n<span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">fork()</code> 프로세스에 의해 새로 생성되는 프로세스는 부프로세스의 프로그램 카운터까지 복제되어 생성된다. 따라서 생성된 이후에 처음부터 프로그램을 실행하는 것이 아니라 생성된 시점의 코드라인부터 실행된다. 먼저 부모 프로세스는 총 3개의 프로세스를 만든다. 가장 처음에 생성된 자녀 프로세스는 자신의 아래에 있는 두 개의 fork 를 통해 2개의 프로세스를 더 만들게 된다. 두 번째 생성된 프로세스는 자신의 아레에 있는 fork를 실행해 한 개의 프로세스를 생성한다. 그리고 마지막에 생성된 프로세스는 곧바로 <code class=\"language-text\">return 0</code>를 만나 종료된다. 자녀 프로세스에 의해 만들어진 새로운 프로세스들 역시 자신의 자녀 프로세스를 생성한다. 가장 처음 생성된 두 개의 프로세스는 증 첫번째 프로세스는 자신의 밑에 새로운 fork() 가 있기 때문에 새로운 프로세스를 하나 만들고 두 번째 프로세스는 return 을 만나 종료된다. 두번 쩨 생성된 프로세스는 하나의 fork()를 생성한다. 글로 적으니까 상당히 복잡하다.. 간단하게 표현해보자.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">P | --C1 | --C11 | --C111 | --C12 | --C2 | --C21 | --C3</code></pre></div>\n<p>이렇게 정리해보면 생성되는 프로세스의 개수는 부모 프로세스를 포함하여 총 8개라는 것을 알 수 있다.</p>\n<p><strong>3.3 Apple 모바일 IOS 운영 체제의 원래 버전은 병행 처리 기법을 제공하지 않았다 병행 처리로 인해 운영체제에 추가되는 세 가지 주요 문제에 대해 논의 하라</strong></p>\n<ul>\n<li>병행 처리가 시스템에 추가되면 운영체제에 몇가지 문제들이 발생한다. 첫 번째는 공유 자원들에 대한 문제이다. 하나의 공유자원에 여러 프로세스가 자신의 작업을 모두 마치기 전에 다른 프로세스가 해당자원에 접근할 수도 있다. 따라서 공유자원에 대한 Mutual Exclusion이 반드시 필요하다. 두 번째는 다수의 프로세스들간의 통신문제이다. 병행 처리에서는 어떤 프로세스가 다른 프로세스의 자원을 요구하는 경우가 있을 수도 있기 때문에 두 프로세스간의 통신이 보장되어야한다. 마지막으로 시스템 리소스에 대한 문제 역시 해결해야 한다. 운영체제는 I/O 와 같은 시스템 리소스들에 대해 한 프로세스가 해당 리소스에 대한 작업을 완전히 마치기 전까지는 다른 프로세스의 작업을 허용해서는 안된다.</li>\n</ul>\n<p><strong>3.4 일부 컴퓨터 시스템은 다수의 레지스터 집합을 제공한다. 새 문맥이 레지스터 집합 중 하나에 이미 적재된 경우 문맥 교환 시 어떤 일이 발생하는지 설명하라. 새 문맥이 레지스터 집합이 아닌 메모리에 있고 모든 레지스터 집합이 사용중이라면 어떤 일이 발생하는가?</strong></p>\n<ul>\n<li>새로운 context가 이미 레지스터 집합에 속해져 있는 경우에는 해당 레지스터 집합을 그대로 사용하기만 하면 된다. 새로운 context가 메모리에 있고 레지스터 집합이 모두 사용중이라면 가득찬 레지스터 집합 중 하나를 replacement 정책에 의해 하나를 밖으로 빼내고 새로 들어온 context를 해당 레지스터 집합에 넣은 뒤 작업을 다시 시작한다.</li>\n</ul>\n<p><strong>3.5 프로세스가 fork() 연산을 사용하여 새로운 프로세스를 생성할 때 어떤 상태가 부모 프로세스와 자식 프로세스 간에 공유되는가?</strong></p>\n<ul>\n<li><code class=\"language-text\">fork()</code> 시스템 콜은 새로운 프로세스를 만들면서 그 부모 프로세스의 모든 메모리 영역과 상태를 그대로 복사한다. 따라서 부모 프로세스와 자식프로세스는 자식프로세스의 생성 시점에서 같은 자원을 가지지만 서로 그 자원들을 공유하지는 않는다. 두 프로세스가 데이터를 공유하게 하려면 공유메모리를 사용하거나 메세지 방식의 IPC기법을 사용해야할 것이다.</li>\n</ul>"}