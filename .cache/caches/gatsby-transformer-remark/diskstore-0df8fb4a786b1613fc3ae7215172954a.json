{"expireTime":9007200877354307000,"key":"transformer-remark-markdown-ast-588f9f3054b28e9e55300caa2cade2d1-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"참고도서: ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":7,"offset":7},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne","position":{"start":{"line":2,"column":8,"offset":8},"end":{"line":2,"column":90,"offset":90},"indent":[]}}],"position":{"start":{"line":2,"column":7,"offset":7},"end":{"line":2,"column":91,"offset":91},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":91,"offset":91},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"3.1 그림 3.30에 표시된 프로그램을 사용하여 LINE A에서 출력되는 내용을 설명하라","position":{"start":{"line":4,"column":3,"offset":95},"end":{"line":4,"column":53,"offset":145},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":93},"end":{"line":4,"column":55,"offset":147},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":93},"end":{"line":4,"column":55,"offset":147},"indent":[]}},{"type":"html","lang":"c","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n\n<span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">pid_t</span> pid<span class=\"token punctuation\">;</span>\n    pid <span class=\"token operator\">=</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pid <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* child process */</span>\n        value <span class=\"token operator\">+=</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pid <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* parent process */</span>\n        <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"PARENT: value = %d\"</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* LINE A*/</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","position":{"start":{"line":6,"column":1,"offset":149},"end":{"line":28,"column":4,"offset":517},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"위 프로그램을 실행하면 ","position":{"start":{"line":30,"column":3,"offset":521},"end":{"line":30,"column":16,"offset":534},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">fork()</code>","position":{"start":{"line":30,"column":16,"offset":534},"end":{"line":30,"column":24,"offset":542},"indent":[]}},{"type":"text","value":" 시스템 콜에 의해 새로운 프로세스가 하나 생성된다. 같은 내용을 가지고 있는 두 프로세스가 만들어지고 이때 부모 프로세스의 ","position":{"start":{"line":30,"column":24,"offset":542},"end":{"line":30,"column":94,"offset":612},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">pid</code>","position":{"start":{"line":30,"column":94,"offset":612},"end":{"line":30,"column":99,"offset":617},"indent":[]}},{"type":"text","value":" 값에 새로 생성된 프로세스의 process idetifier 가 저장되게 된다. 생성된 자녀 프로세스의 ","position":{"start":{"line":30,"column":99,"offset":617},"end":{"line":30,"column":158,"offset":676},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">pid</code>","position":{"start":{"line":30,"column":158,"offset":676},"end":{"line":30,"column":163,"offset":681},"indent":[]}},{"type":"text","value":" 값은 0이 되므로 두 프로세스는 각각 조건문의 다른 분기로 나누어져서 실행을 하게 된다. 먼저 부모 프로세스는 ","position":{"start":{"line":30,"column":163,"offset":681},"end":{"line":30,"column":226,"offset":744},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">else if</code>","position":{"start":{"line":30,"column":226,"offset":744},"end":{"line":30,"column":235,"offset":753},"indent":[]}},{"type":"text","value":" 문으로 진입하자마자 ","position":{"start":{"line":30,"column":235,"offset":753},"end":{"line":30,"column":247,"offset":765},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">wait()</code>","position":{"start":{"line":30,"column":247,"offset":765},"end":{"line":30,"column":255,"offset":773},"indent":[]}},{"type":"text","value":" 시스템콜을 통해서 자녀 프로세스가 끝날 때까지 대기하게 된다. 그리고 동시에 자녀 프로세스는 ","position":{"start":{"line":30,"column":255,"offset":773},"end":{"line":30,"column":308,"offset":826},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">if</code>","position":{"start":{"line":30,"column":308,"offset":826},"end":{"line":30,"column":312,"offset":830},"indent":[]}},{"type":"text","value":" 문 안으로 들어가서 ","position":{"start":{"line":30,"column":312,"offset":830},"end":{"line":30,"column":324,"offset":842},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">value</code>","position":{"start":{"line":30,"column":324,"offset":842},"end":{"line":30,"column":331,"offset":849},"indent":[]}},{"type":"text","value":" 의 값을 15 증가시킨다. 자녀 프로세스가 값을 증가시키고 종료되면, wait 시스템 콜에 의해 대기 중이던 부모 프로세스가 실행되고 부모 프로세스의 안에서 value 의 값은 5이기 때문에 LINE A는 ","position":{"start":{"line":30,"column":331,"offset":849},"end":{"line":30,"column":447,"offset":965},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">PARENT: value = 5</code>","position":{"start":{"line":30,"column":447,"offset":965},"end":{"line":30,"column":466,"offset":984},"indent":[]}},{"type":"text","value":" 를 출력하고 종료된다.","position":{"start":{"line":30,"column":466,"offset":984},"end":{"line":30,"column":479,"offset":997},"indent":[]}}],"position":{"start":{"line":30,"column":3,"offset":521},"end":{"line":30,"column":479,"offset":997},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":519},"end":{"line":30,"column":479,"offset":997},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":519},"end":{"line":30,"column":479,"offset":997},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"3.2 최초의 부모 프로세스를 포함하여 그림 3.31에 표시된 프로그램의 의해 몇 개의 프로세스가 생성되는가?","position":{"start":{"line":32,"column":3,"offset":1001},"end":{"line":32,"column":64,"offset":1062},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":999},"end":{"line":32,"column":66,"offset":1064},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":999},"end":{"line":32,"column":66,"offset":1064},"indent":[]}},{"type":"html","lang":"c","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">/* fork a child process */</span>\n<span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* fork another child process */</span>\n<span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* and fork another */</span>\n<span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","position":{"start":{"line":34,"column":1,"offset":1066},"end":{"line":50,"column":4,"offset":1250},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"html","value":"<code class=\"language-text\">fork()</code>","position":{"start":{"line":52,"column":3,"offset":1254},"end":{"line":52,"column":11,"offset":1262},"indent":[]}},{"type":"text","value":" 프로세스에 의해 새로 생성되는 프로세스는 부프로세스의 프로그램 카운터까지 복제되어 생성된다. 따라서 생성된 이후에 처음부터 프로그램을 실행하는 것이 아니라 생성된 시점의 코드라인부터 실행된다. 먼저 부모 프로세스는 총 3개의 프로세스를 만든다. 가장 처음에 생성된 자녀 프로세스는 자신의 아래에 있는 두 개의 fork 를 통해 2개의 프로세스를 더 만들게 된다. 두 번째 생성된 프로세스는 자신의 아레에 있는 fork를 실행해 한 개의 프로세스를 생성한다. 그리고 마지막에 생성된 프로세스는 곧바로 ","position":{"start":{"line":52,"column":11,"offset":1262},"end":{"line":52,"column":291,"offset":1542},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">return 0</code>","position":{"start":{"line":52,"column":291,"offset":1542},"end":{"line":52,"column":301,"offset":1552},"indent":[]}},{"type":"text","value":"를 만나 종료된다. 자녀 프로세스에 의해 만들어진 새로운 프로세스들 역시 자신의 자녀 프로세스를 생성한다. 가장 처음 생성된 두 개의 프로세스는 증 첫번째 프로세스는 자신의 밑에 새로운 fork() 가 있기 때문에 새로운 프로세스를 하나 만들고 두 번째 프로세스는 return 을 만나 종료된다. 두번 쩨 생성된 프로세스는 하나의 fork()를 생성한다. 글로 적으니까 상당히 복잡하다.. 간단하게 표현해보자.","position":{"start":{"line":52,"column":301,"offset":1552},"end":{"line":52,"column":530,"offset":1781},"indent":[]}}],"position":{"start":{"line":52,"column":3,"offset":1254},"end":{"line":52,"column":530,"offset":1781},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":1252},"end":{"line":52,"column":530,"offset":1781},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":1252},"end":{"line":52,"column":530,"offset":1781},"indent":[]}},{"type":"html","lang":"json","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">P | --C1 | --C11 | --C111 | --C12 | --C2 | --C21 | --C3</code></pre></div>","position":{"start":{"line":54,"column":1,"offset":1783},"end":{"line":56,"column":4,"offset":1850},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"이렇게 정리해보면 생성되는 프로세스의 개수는 부모 프로세스를 포함하여 총 8개라는 것을 알 수 있다.","position":{"start":{"line":58,"column":1,"offset":1852},"end":{"line":58,"column":57,"offset":1908},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":1852},"end":{"line":58,"column":57,"offset":1908},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"3.3 Apple 모바일 IOS 운영 체제의 원래 버전은 병행 처리 기법을 제공하지 않았다 병행 처리로 인해 운영체제에 추가되는 세 가지 주요 문제에 대해 논의 하라","position":{"start":{"line":60,"column":3,"offset":1912},"end":{"line":60,"column":95,"offset":2004},"indent":[]}}],"position":{"start":{"line":60,"column":1,"offset":1910},"end":{"line":60,"column":97,"offset":2006},"indent":[]}}],"position":{"start":{"line":60,"column":1,"offset":1910},"end":{"line":60,"column":97,"offset":2006},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"병행 처리가 시스템에 추가되면 운영체제에 몇가지 문제들이 발생한다. 첫 번째는 공유 자원들에 대한 문제이다. 하나의 공유자원에 여러 프로세스가 자신의 작업을 모두 마치기 전에 다른 프로세스가 해당자원에 접근할 수도 있다. 따라서 공유자원에 대한 Mutual Exclusion이 반드시 필요하다. 두 번째는 다수의 프로세스들간의 통신문제이다. 병행 처리에서는 어떤 프로세스가 다른 프로세스의 자원을 요구하는 경우가 있을 수도 있기 때문에 두 프로세스간의 통신이 보장되어야한다. 마지막으로 시스템 리소스에 대한 문제 역시 해결해야 한다. 운영체제는 I/O 와 같은 시스템 리소스들에 대해 한 프로세스가 해당 리소스에 대한 작업을 완전히 마치기 전까지는 다른 프로세스의 작업을 허용해서는 안된다.","position":{"start":{"line":62,"column":3,"offset":2010},"end":{"line":62,"column":389,"offset":2396},"indent":[]}}],"position":{"start":{"line":62,"column":3,"offset":2010},"end":{"line":62,"column":389,"offset":2396},"indent":[]}}],"position":{"start":{"line":62,"column":1,"offset":2008},"end":{"line":62,"column":389,"offset":2396},"indent":[]}}],"position":{"start":{"line":62,"column":1,"offset":2008},"end":{"line":62,"column":389,"offset":2396},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"3.4 일부 컴퓨터 시스템은 다수의 레지스터 집합을 제공한다. 새 문맥이 레지스터 집합 중 하나에 이미 적재된 경우 문맥 교환 시 어떤 일이 발생하는지 설명하라. 새 문맥이 레지스터 집합이 아닌 메모리에 있고 모든 레지스터 집합이 사용중이라면 어떤 일이 발생하는가?","position":{"start":{"line":64,"column":3,"offset":2400},"end":{"line":64,"column":151,"offset":2548},"indent":[]}}],"position":{"start":{"line":64,"column":1,"offset":2398},"end":{"line":64,"column":153,"offset":2550},"indent":[]}}],"position":{"start":{"line":64,"column":1,"offset":2398},"end":{"line":64,"column":153,"offset":2550},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"새로운 context가 이미 레지스터 집합에 속해져 있는 경우에는 해당 레지스터 집합을 그대로 사용하기만 하면 된다. 새로운 context가 메모리에 있고 레지스터 집합이 모두 사용중이라면 가득찬 레지스터 집합 중 하나를 replacement 정책에 의해 하나를 밖으로 빼내고 새로 들어온 context를 해당 레지스터 집합에 넣은 뒤 작업을 다시 시작한다.","position":{"start":{"line":66,"column":3,"offset":2554},"end":{"line":66,"column":203,"offset":2754},"indent":[]}}],"position":{"start":{"line":66,"column":3,"offset":2554},"end":{"line":66,"column":203,"offset":2754},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":2552},"end":{"line":66,"column":203,"offset":2754},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":2552},"end":{"line":66,"column":203,"offset":2754},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"3.5 프로세스가 fork() 연산을 사용하여 새로운 프로세스를 생성할 때 어떤 상태가 부모 프로세스와 자식 프로세스 간에 공유되는가?","position":{"start":{"line":68,"column":3,"offset":2758},"end":{"line":68,"column":78,"offset":2833},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":2756},"end":{"line":68,"column":80,"offset":2835},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":2756},"end":{"line":68,"column":80,"offset":2835},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"html","value":"<code class=\"language-text\">fork()</code>","position":{"start":{"line":70,"column":3,"offset":2839},"end":{"line":70,"column":11,"offset":2847},"indent":[]}},{"type":"text","value":" 시스템 콜은 새로운 프로세스를 만들면서 그 부모 프로세스의 모든 메모리 영역과 상태를 그대로 복사한다. 따라서 부모 프로세스와 자식프로세스는 자식프로세스의 생성 시점에서 같은 자원을 가지지만 서로 그 자원들을 공유하지는 않는다. 두 프로세스가 데이터를 공유하게 하려면 공유메모리를 사용하거나 메세지 방식의 IPC기법을 사용해야할 것이다.","position":{"start":{"line":70,"column":11,"offset":2847},"end":{"line":70,"column":200,"offset":3036},"indent":[]}}],"position":{"start":{"line":70,"column":3,"offset":2839},"end":{"line":70,"column":200,"offset":3036},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":2837},"end":{"line":70,"column":200,"offset":3036},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":2837},"end":{"line":70,"column":200,"offset":3036},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":71,"column":1,"offset":3037}}}}