{"expireTime":9007200877354308000,"key":"transformer-remark-markdown-html-7b1332b0a83a81d2111af952d3ecaa42-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":"<p><code class=\"language-text\">Shortest Path(최단 경로)</code>는 가중치가 있는 그래프에서 어떤 정점에서 다른 정점으로 이동하기까지 가장 짧은 가중치의 합으로 목적지에 도달하는 방법을 찾기 위한 전략이다.</p>\n<p>최단 경로문제는 몇가지 유형으로 나누어진다.</p>\n<ol>\n<li>Single Source: 하나의 노드로부터 출발해서 다른 모든 노드의 최단 경로를 찾는 문제</li>\n<li>Single Destination: 모든 노드로부터 하나의 목적지 까지의 최단 경로를 찾는 문제</li>\n<li>Single Pair: 주어진 하나의 노드로부터 하나의 목적지까지의 최단 경로를 찾는 문제</li>\n<li>All pair: 모든 노드 쌍에 대한 최단 경로를 찾는 문제</li>\n</ol>\n<p>이번 수업에서 주로 다룰 내용은 <code class=\"language-text\">SSP</code> 라고도 부르는 Single-source Shortest Path 이다.</p>\n<h2 id=\"lemma\" style=\"position:relative;\"><a href=\"#lemma\" aria-label=\"lemma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lemma</h2>\n<p>일단 Shortest Path 문제를 어떻게 풀 수 있을지 생각해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA1ElEQVQY06WRUU/DMAyE+///F7AhbeJh2guCrWObVglU1jWxEzs5nLKhljfESZb8+RQnp1Q5Z9xU+hFeOf+Jq9KopokhqsX+YTUe+ymlocaLyo6iqvMR8w3h+eTNUTSfhNmG8fZB5SjaC+GxZvONcwJxwHJHWB0YIjLUau+wsBkFQdX2AXevjPXBQwOhbjrc14qXxiFJwOn9jIdasD56SGS0584uCHjaBxB5OOew3PaYbxmOY4mc4SheY36r9zyJ5ChMfLKDbK+5KYrC22yI/N9P+M1fOurUtM6+kigAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/1a205a372470f925cf3efbb6792f97e1/c1b63/1.png\"\n        srcset=\"/static/1a205a372470f925cf3efbb6792f97e1/5a46d/1.png 300w,\n/static/1a205a372470f925cf3efbb6792f97e1/0a47e/1.png 600w,\n/static/1a205a372470f925cf3efbb6792f97e1/c1b63/1.png 1200w,\n/static/1a205a372470f925cf3efbb6792f97e1/d0ab7/1.png 1532w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p><em>명제:</em>\n위와 같이 어떤 지점 U로 부터 V까지 가는 경로가 있다고 하고 이 경로가 U에서 V로 가는 가능한 짧은 경로라고 해보자. 즉, 경로 UV는 U에서 V로 가는 SSP의 <code class=\"language-text\">Global Optimal Solution</code> 이다. 그리고 이 경로 안에 속하는 다른 모든 경로는 해당 지점까지의 최단 경로이다. 즉, <code class=\"language-text\">Optimal Sub Structure</code> 가 존재한다.</p>\n<p><em>증명:</em>\nProof by Contradiction으로 증명해보자. 만약 경로 UV가 최단 경로일 때, 해당 경로에 속하는 subpath 가 Optimal substructure 가 아니라면, 해당 subpath 보다 더 짧은 subpath가 있다는 것을 의미한다. 현재 subpath 보다 짧은 subpath 가 있다면, global optimal solution을 위해서는 해당 subpath을 최종 solution에 반드시 포함해야 하고, 이는 곧 초기에 설정했던 경로 UV가 더 이상 최단경로가 될 수 없음을 의미한다. 따라서 어떤 최단 경로가 있다면, 그 안에 속한 다른 모든 경로들도 최단 경로이다.</p>\n<h2 id=\"properties\" style=\"position:relative;\"><a href=\"#properties\" aria-label=\"properties permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Properties</h2>\n<p>위 증명에 따라 우리는 다음과 같은 결론을 낼 수 있다.</p>\n<ul>\n<li>어떤 경로 UV가 최단 경로라면, 이 경로의 길이는 그래프 내에 다른 정점들을 거쳐서 오는 모든 경로보다 같거나 작다.</li>\n</ul>\n<h2 id=\"negative-weight-cycle\" style=\"position:relative;\"><a href=\"#negative-weight-cycle\" aria-label=\"negative weight cycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Negative-Weight Cycle</h2>\n<p>그래프의 최단 경로를 찾는 것은 그래프에 negative-weight cycle 이 없을 때만 가능하다. <code class=\"language-text\">Negative-Weight Edge</code>는 음수를 가중치를 가지는 간선인데 이 간선이 그래프에 포함되어 있고, 다른 간선과 사이클을 만든다고 생각해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGklEQVQoz32R607DMAyF+/6vhMRFAn4C4g6DbWirxti6tWubS9PkI2nHgGqdJSs+8bFz7ET0mHMO10YsN4ok103sr5tcn0WHGgYrZcXFUHM5UghV/cvtbRiSNqjZkrrY1JabccZjXGCt/VXfqfnxaJ+qv7iuayolkGWO1rp3kp1CpQ2TRCL8GUybmslSUCqzI8VJwcfn2iusG1zIUCOoTIutdcQrSVpoore54Oi14imMpAXP05SToePBY6MliyTlbCA5f5dkeYkSBdfjDacjGM5znFGMZ2uOB5qriSJa+a63U8HC/6R/i1WuuIslX1mLdWV4mQkGc4kJipxltpbce05Wtj9fSO0FCK9abXfobGcxtruprR/gNNjxDVP4cJuKacohAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"2\"\n        src=\"/static/41b1540ed0d543e4ac29be8b1651a776/c1b63/2.png\"\n        srcset=\"/static/41b1540ed0d543e4ac29be8b1651a776/5a46d/2.png 300w,\n/static/41b1540ed0d543e4ac29be8b1651a776/0a47e/2.png 600w,\n/static/41b1540ed0d543e4ac29be8b1651a776/c1b63/2.png 1200w,\n/static/41b1540ed0d543e4ac29be8b1651a776/536c7/2.png 1480w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 그래프에서 정점 A와 정점 B가 만드는 사이클에 도달하게 되면, 사이클을 만드는 두 가중치의 합이 -7이기 때문에, 탐색을 거듭할 때마다. 가중치의 합이 계속해서 작아지면서 결국 -∞ 에 수렴하게 된다. 이렇게 되면 우리는 최단경로를 구할 수가 없게된다.</p>\n<h2 id=\"other-cycles\" style=\"position:relative;\"><a href=\"#other-cycles\" aria-label=\"other cycles permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Other Cycles?</h2>\n<p>그럼 이런 의문이 들 수도 있다. <code class=\"language-text\">&quot;단순히 사이클이 문제인가?&quot;</code>. 정답은 “아니다” 이다. Negative weight cycle 외에 가능한 다른 사이클들은 다음과 같다.</p>\n<ol>\n<li>Postivie Weight Cycle: 이 사이클은 탐색을 거듭할수록 양수 값으로 증가하기 때문에 결국엔 +∞ 로 길이가 수렴하게 된다. 우리가 구하고자 하는 값은 최단 거리이기 때문에 어차피 양의 무한대로 수렴하는 사이클이라면 이 사이클을 그냥 무시해도 우리가 최단 경로를 구하는데는 아무 지장이 없을 것이다.</li>\n<li>Zero-Weight Cycle: 이 사이클은 사이클을 이루는 두 간선의 합이 0일 때 생기는 사이클인데, 이 사이클을 포함하든 포함하지만 않든 전체 최단 경로의 값에 영향을 주지 않기 때문에 고려하지 않아도 된다.</li>\n</ol>\n<h2 id=\"algorithm-strategy-for-ssp\" style=\"position:relative;\"><a href=\"#algorithm-strategy-for-ssp\" aria-label=\"algorithm strategy for ssp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithm Strategy for SSP</h2>\n<p>여러 알고리즘 접근을 알아보기 전에 SSP 알고리즘 접근에 통용되는 몇가지 용어와 방법들을 정리해보자. 일단 SSP는 어떤 정점에 대해 다른 모든 정점으로의 최단경로를 구하는 전략이라는 것을 기억하자.</p>\n<h3 id=\"distance\" style=\"position:relative;\"><a href=\"#distance\" aria-label=\"distance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Distance</h3>\n<p>어떤 두 정점 사이의 길이를 저장하기 위해 배열을 사용한다. <code class=\"language-text\">d[v]</code> 는 시작점으로 부터 정점 v까지의 최단 길이를 저장한다. 따라서 여러 경로가 발견될 때 가장 길이가 짧은 경로의 길이 합을 이 배열에 저장해야한다. 최단 길이를 저장해야하기 때문에 가장 초기값은 +∞로 지정되어야 할 것이다.</p>\n<h3 id=\"predecessor\" style=\"position:relative;\"><a href=\"#predecessor\" aria-label=\"predecessor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Predecessor</h3>\n<p>어떤 정점에서 최단경로로 연결된 다른 정점을 표현하기 위해서 배열을 사용한다. <code class=\"language-text\">p[v]</code> 는 최단 경로를 구성하는 정점들 중 v의 부모노드가 되는 정점을 저장한다.</p>\n<h3 id=\"relaxation\" style=\"position:relative;\"><a href=\"#relaxation\" aria-label=\"relaxation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Relaxation</h3>\n<p>최단 경로를 찾는 문제에서 가장 핵심이 되는 것이 이 relaxation 기법이다. <code class=\"language-text\">Relaxation</code>은 어떤 한 정점으로부터 연결된 모든 정점을 탐색하고 그 중에서 가장 길이가 짧은 정점을 찾아 Shortest Path를 만드는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Relax (u, v, w){\n    if(d[v] &gt; d[u]+w)\n        then\n            d[v] = d[u]+w;\n            p[v] = u;\n}</code></pre></div>\n<p>수도코드는 위와 같다. 현재까지 알고있던 최단 경로가 s->v 라고 했을 때, s에서 u를 거쳐 v에 도달할 때 그 길이가 더 짧다는 것이 발견된다면, 해당 값을 최단경로로 지정하는 것이다.</p>"}