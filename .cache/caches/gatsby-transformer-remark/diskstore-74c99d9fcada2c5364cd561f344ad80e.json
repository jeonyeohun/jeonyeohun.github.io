{"expireTime":9007200877354306000,"key":"transformer-remark-markdown-html-b71964e03b71c7211399a5dc0c901dfc-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":"<p><em><strong>참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음</strong></em></p>\n<h2 id=\"네트워크-계층\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5\" aria-label=\"네트워크 계층 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 계층</h2>\n<p>네트워크 계층은 호스트와 호스트간의 패킷을 전달하는 논리적 역할을 하는 계층이다. 네트워크 계층의 기능은 크게 두 가지로 나눌 수 있다.</p>\n<ol>\n<li>Forwarding(Data Plane) : 데이터를 다루는 <code class=\"language-text\">Data plane</code> 영역에서는 패킷을 어떻게 전달할지를 결정하게 된다. 이 영역은 다른 라우터들과는 전혀 관계없이 현재 패킷을 가지고 있는 라우터만 고려하면 된다.</li>\n<li>Routing(Control Plane) : 제어를 담당하는 <code class=\"language-text\">Control plane</code> 영역에서는 패킷을 어떤 경로로 전달하지 그 최적의 경로를 결정하는 역할을 한다. 최적의 경로를 찾아야하기 때문에 이 영역은 다른 라우터들에 대한 정보를 필요로 하고 특정한 라우팅 알고리즘을 통해서 최적의 경로를 설정한다. 이 라우팅 알고리즘을 통해서 라우터는 <code class=\"language-text\">forwarding table</code> 을 가지게 되는데, 이 테이블은 전달받은 패킷 헤더의 필드값을 조사해서 얻은 값을 포워딩 테이블의 인덱스로 사용해 해당 패킷이 전달되어야 할 다음 경로를 라우터에게 알려준다.</li>\n</ol>\n<h2 id=\"forwaring-table-의-생성\" style=\"position:relative;\"><a href=\"#forwaring-table-%EC%9D%98-%EC%83%9D%EC%84%B1\" aria-label=\"forwaring table 의 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Forwaring Table 의 생성</h2>\n<p>forwarding table 은 두 가지 다른 방법으로 구성될 수 있다.</p>\n<ol>\n<li>Per-router Control Plane: 이 방법은 네트워크 내에 있는 각각의 라우터들이 서로 라우팅 메세지를 교환하며 포워딩 테이블의 값을 계산하는 가장 전통적인 방식이다. 각 라우터들이 라우팅 알고리즘을 실행하고 다른 라우터들과 정보를 주고받아야하기 때문에 포워딩과 라우팅 기능을 모두 제공해야한다.</li>\n<li>Logically Centralized Control Plane: 이 방법은 물리적으로 라우터들과 분리된 원격 컨트롤러 컴퓨터가 라우팅 알고리즘을 수행해서 포워딩 테이블을 생성하고, 각 라우터들은 만들어진 테이블을 기반으로 포워딩 기능만을 수행한다.</li>\n</ol>\n<h2 id=\"네트워크-계층의-기능\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5%EC%9D%98-%EA%B8%B0%EB%8A%A5\" aria-label=\"네트워크 계층의 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 계층의 기능</h2>\n<p>네트워크 계층은 다음과 같은 기능들을 제공한다.</p>\n<ol>\n<li>Addressing: 패킷의 목적지를 설정.</li>\n<li>Routing: 패킷의 전송경로를 설정.</li>\n<li>Fragmentation: 패킷을 더 작은 조각으로 나누고 나뉘어진 채로 전달된 패킷을 다시 합친다.</li>\n<li>Packetization: 윗 계층에서 전달된 세그먼트를 데이터그램으로 캡슐화한다.</li>\n</ol>\n<p>1, 2, 4 번은 모두 앞선 공부들에서 정리했으니, <code class=\"language-text\">Fragmentation</code> 을 먼저 정리해보자.</p>\n<h3 id=\"fragmentation\" style=\"position:relative;\"><a href=\"#fragmentation\" aria-label=\"fragmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragmentation</h3>\n<p>Layer 2 인 <code class=\"language-text\">링크 계층</code>에서는 각 네트워크의 링크들이 한번에 전달할 수 있는 최대 데이터 양을 규정하고, 이를 <code class=\"language-text\">MTU(Maximum Transmission Unit)</code> 이라고 한다. 문제는 각 라우터들이 각기 다른 MTU를 가지고 있기 때문에 가장 처음에는 전달할때는 패킷의 사이즈가 괜찮았더라도, 중간 링크에서 해당 패킷을 전달할 수 없는 상황이 생길 수도 있다.</p>\n<p>Fragmentation은 이와 같은 문제를 해결하기 위해서 데이터그램을 더 작은 단위로 나누고 링크계층으로 보내 별도의 패킷으로 나누어서 보내는 방법이다. 이때 패킷의 경로에 있는 모든 라우터를 확인해서 가장 MTU가 작은 값을 <code class=\"language-text\">Path MTU</code> 라고 하고, 이 방법은 주로 <code class=\"language-text\">IPv6</code> 에서 사용된다. <code class=\"language-text\">IPv4</code> 에서는 패킷의 fragmentation 과 reassembly 를 위해서 몇가지 헤더필드를 사용하는데, 다음헤더들이 그 기능을 수행한다:</p>\n<ol>\n<li>Identification: 식별자 역할을하는 이 헤더필드는 새로운 데이터그램이 들어올 때마다 1씩 증가시켜서 각 데이터그램이 <code class=\"language-text\">고유한 식별자</code>를 갖게끔 한다. 이 식별자는 fragmentation이 된다고 하더라도 나누어진 데이터그램들이 같은 식별자를 가지기 때문에 여러 패킷조각들이 한 데이터그램에서 왔다는 것을 알 수 있게 해준다.</li>\n<li>Flags: 이 헤더필드에 <code class=\"language-text\">DF bit</code> 가 설정되면 이 헤더를 가진 데이터그램은 fragmeation이 되면 안된다는 것을 의미한다. 만약 DF bit를 가진 데이터그램이 라우터에 도착하고 이 데이터그램을 fragmentation 해야하는 상황이 발생하면, 라우터는 이 데이터그램을 버리고 <code class=\"language-text\">ICMP</code>로 에러를 알리는 패킷을 보낸다. <code class=\"language-text\">MF bit</code> 는 fragment 된 데이터그램들 중 마지막을 제외한 모든 패킷이 가지게 된다. 이렇게 마지막을 제외한 모든 패킷에 MF 비트를 주어서 마지막까지 나누어진 패킷이 모두 도착했는지를 알 수 있다.</li>\n<li>Fragment Offset: 데이터가 나누어진 조각의 위치를 명시하기 위해서 사용한다. offset에 8을 곱하면 실제 데이터의 위치 값을 얻을 수 있다.</li>\n</ol>\n<h3 id=\"reassembly\" style=\"position:relative;\"><a href=\"#reassembly\" aria-label=\"reassembly permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reassembly</h3>\n<ul>\n<li>여러조각으로 나뉘어져 도착한 fragment 들을 다시 하나로 합쳐 데이터그램으로 만들려면, 어느단계에서 합치는 작업을 해야할지 정하는 것이 중요하다.</li>\n<li>IP에서는 최종 목적지에 도착한 이후에 다시 합치도록 한다.</li>\n<li>이떄 발생하는 단점은 하나의 fragment만 유실되더라도 모든 조각들을 다 버려야 하고, 무한정 fragment 를 기다리지 않게 하기 위해 사용하는 reassembly timer 가 종료 되었을 때도 모든 조각들을 다 버려야 한다는 점이다.</li>\n</ul>\n<h2 id=\"internet-protocol--ipv4\" style=\"position:relative;\"><a href=\"#internet-protocol--ipv4\" aria-label=\"internet protocol  ipv4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Internet Protocol : IPv4</h2>\n<ul>\n<li>IPv4는 Best-effort service 를 지원한다. 따라서 최선을 다하지만, 데이터 전달, 오류, 전달 순서 등을 항상 보장하지는 않는다.</li>\n<li>Routing 은 별도의 프로토콜을 통해서 수행하고 <code class=\"language-text\">Forwarding</code> 기능만 수행한다.</li>\n<li>IPv4 의 헤더는 다음과 같이 구성된다.</li>\n<li><code class=\"language-text\">VER(4 bits)</code> : 현재 IP 프로토콜의 버전. IPv4 는 4 를 기입힌다.</li>\n<li><code class=\"language-text\">HLEN(4 bits)</code> : 헤더의 길이를 기입한다. 일반적으로 옵션을 포함하지 않으면 <code class=\"language-text\">20 바이트</code> 가 헤더길이가 된다.</li>\n<li><code class=\"language-text\">Service(8 bits)</code> : 여러 다른 유형의 데이터그램을 식별하기 위해서 사용하지만, 잘 사용되지 않고 ECN 같은 비트를 넣어서 Congestion Control을 하는데에 사용하기도 한다.</li>\n<li><code class=\"language-text\">Total Length(16 bits)</code> : 바이트로 계산한 헤더와 데이터의 전체 길이를 기입한다.</li>\n<li><code class=\"language-text\">Identification(16 bits)</code> : fragmentation 처리에 사용될 데이터그램의 식별자를 입력한다. 새로운 데이터그램이 들어오면 1씩 증가시킨 값을 할당해서 데이터그램들이 고유한 값을 가지도록 한다.</li>\n<li><code class=\"language-text\">Flags(3 bits)</code> : 조각난 데이터그램을 표현하고 조각들의 마지막 패킷을 표시하기 위해서 사용한다.</li>\n<li><code class=\"language-text\">Fragmentation offset(13 bits)</code> : 데이터들의 실제 위치를 기록해서 다시 합칠 때 순서를 유지할 수 있도록 한다.</li>\n<li><code class=\"language-text\">Time To Live(8 bits)</code> : 라우터 하나를 거칠때마다 1씩 감소하고, 0이 되면 해당 패킷은 버려진다.</li>\n<li>P<code class=\"language-text\">rotocol(8 bits)</code> : 상위 계층에서 이 데이터그램을 받아 사용할 프로토콜을 명시한다. 즉, 트랜스포트 계층에서 사용할 프로토콜이 UDP가 될지, TCP가 될지 기록하게 된다.</li>\n<li><code class=\"language-text\">Header Checksum(16 bits)</code> : 헤더와 데이터를 사용해서 체크섬을 만들어 오류확인에 도움을 준다.</li>\n<li><code class=\"language-text\">Source IP address(32 bits)</code> : 데이터그램을 전송한 호스트의 ip 주소를 기입한다.</li>\n<li><code class=\"language-text\">Destination IP address(32 bits)</code> : 데이터그램을 수신할 목적지 호스트의 ip주소를 기입한다.</li>\n</ul>\n<h3 id=\"ipv4-addressing\" style=\"position:relative;\"><a href=\"#ipv4-addressing\" aria-label=\"ipv4 addressing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IPv4 Addressing</h3>\n<ul>\n<li>ip 주소는 각 호스트에 연결된 <code class=\"language-text\">Network Interface Card</code> 마다 하나씩 부여된다. 그리고 이 주소는 전세계에 하나 뿐인 고유한 주소가 된다.</li>\n<li>각 호스트나 라우터가 물리적 링크와 연결되는 지점을 <code class=\"language-text\">Interface</code> 라고 한다.</li>\n<li>IPv4의 주소체계는 계층적 구조로 이루어져 있고, 32 비트 주소를 <code class=\"language-text\">network id</code> 와 <code class=\"language-text\">host id</code> 로 나누어서 사용한다. 따라서 한 네트워크 그룹에 속한 모든 호스트는 같은 network number 를 공유하게 된다.</li>\n<li><code class=\"language-text\">InterNIC</code> 는 <code class=\"language-text\">AS(Autonomous System)</code> 라고 불리는 네트워크 관리 주체에 <code class=\"language-text\">network id</code>를 부여하고 각 AS는 네트워크 내의 호스트들에게 <code class=\"language-text\">host id</code> 를 부여한다.</li>\n<li>IPv4는 <code class=\"language-text\">Dotted Deicmal</code> 체계로 주소를 표현하는데, 이진수로 표현된 주소를 8비트씩 잘라서 10진수로 변환한 뒤에 사이사이에 점을 찍어 표현하는 형태이다. 예를 들어 <code class=\"language-text\">11000000 00000101 00110000 00000011</code> 로 표현된 주소는 <code class=\"language-text\">192.5.48.3</code> 으로 변환된다.</li>\n</ul>\n<h3 id=\"classful-ip-addressing\" style=\"position:relative;\"><a href=\"#classful-ip-addressing\" aria-label=\"classful ip addressing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Classful IP Addressing</h3>\n<p>IPv4 의 초창기에는 주소를 여러 클래스로 나누어서 net id와 host id 의 비율을 결정하는 방식으로 주소를 할당했다. 이 비율은 host id의 비트로 표현할 수 있는 최대 갯수를 결정하기 때문에, 네트워크에 참여하는 호스트들의 개수가 중요하다.</p>\n<ul>\n<li>각 클래스들을 식별하기 위해서 주소의 앞 몇 비트들을 클래스 식별자로 사용하는데 각 식별자와 범위는 다음과 같다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">클래스</th>\n<th align=\"center\">식별자</th>\n<th align=\"center\">NetID 사용 비트</th>\n<th align=\"center\">HostID 사용 비트</th>\n<th align=\"center\">시작주소</th>\n<th align=\"center\">끝주소</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\">0XXXXXXXX</td>\n<td align=\"center\">7</td>\n<td align=\"center\">24</td>\n<td align=\"center\">0.0.0.0</td>\n<td align=\"center\">127.255.255.255</td>\n</tr>\n<tr>\n<td align=\"center\">B</td>\n<td align=\"center\">10XXXXXXX</td>\n<td align=\"center\">14</td>\n<td align=\"center\">16</td>\n<td align=\"center\">128.0.0.0</td>\n<td align=\"center\">191.255.255.255</td>\n</tr>\n<tr>\n<td align=\"center\">C</td>\n<td align=\"center\">110XXXXXX</td>\n<td align=\"center\">21</td>\n<td align=\"center\">8</td>\n<td align=\"center\">192.0.0.0</td>\n<td align=\"center\">223.255.255.255</td>\n</tr>\n<tr>\n<td align=\"center\">D</td>\n<td align=\"center\">1110XXXXX</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">224.0.0.0</td>\n<td align=\"center\">239.255.255.255</td>\n</tr>\n<tr>\n<td align=\"center\">E</td>\n<td align=\"center\">1111XXXXX</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">240.0.0.0</td>\n<td align=\"center\">255.255.255.255</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Class A 부터 C 까지는 <code class=\"language-text\">Unicast address</code> 이고 D는 <code class=\"language-text\">Multicast address</code> 인데, 각 주소에 맵핑되는 호스트들이 1대1 관계인지 1대다 관계인지에 따라 나뉜다.</li>\n</ul>\n<h3 id=\"subnetting\" style=\"position:relative;\"><a href=\"#subnetting\" aria-label=\"subnetting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Subnetting</h3>\n<ul>\n<li>Subnet 이라는 기술은 여러개의 인터페이스가 서로 연결되는 네트워크를 의미한다. 서브넷에 있는 ip 주소들은 서로 공통된 ip 주소의 일부를 공유하게 되는데 이때 사용하는 주소 체계를 <code class=\"language-text\">CIDR(Classless InterDomain Routing)</code>이라고 한다. CIDR 은 공통된 ip 주소와 함께 슬래쉬와 비트수를 사용해서 주소를 나타낸다. 예를 들어 233.1.1.2, 233.1.1.4, 233.1.1.5 로 구성된 서브넷이 있다고 하면, <code class=\"language-text\">233.1.1/24</code> 와 같이 나타내고 <code class=\"language-text\">/24</code> 부분을 <code class=\"language-text\">Subnet Mask</code> 라고 한다.</li>\n<li>CIDR을 사용하면 해당 주소를 읽을 수 있는 라우터에서 일단 CIDR의 공통된 주소를 받는 요청을 모두 받고 서브넷 안의 호스트에게 나누어주면 되기 때문에 훨씬 더 효율적으로 주소를 처리할 수 있게된다. 이렇게 모든 서브넷 호스트의 ip주소를 포함하는 ip주소를 한 라우터에서 처리할 수 있게 하는 방법을 <code class=\"language-text\">route aggregation</code> 이라고 한다.</li>\n<li>그렇다면 만약 다음과 같은 상황에서는 어떨까? <code class=\"language-text\">11001000 00010111 00010000 00000000</code> 이라는 주소가 있고, <code class=\"language-text\">11001000 00010111 00010010 00000000</code> 두 개의 주소가 각각 다른 인터페이스와 매핑되어 있을 때 두 주소를 모두 포함하는 주소가 새로 들어온다면, 어떤 인터페이스 경로로 가야할까? 왜냐하면 두 번째 주소는 0001 까지는 첫 주소의 인터페이스와 매치되고, 0001001 까지는 두번째 주소의 인ㅌ터페이스와 매칭되기 때문에 자칫하면 항상 첫번째 인터페이스로 이동하게되기 때문이다. 따라서 CIDR 정책을 사용할 때는 항상 주소를 가장 길게 매칭되는 지점까지 검사해야할 필요가 있다.</li>\n</ul>"}