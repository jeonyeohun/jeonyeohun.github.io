{"expireTime":9007200877354306000,"key":"transformer-remark-markdown-html-4c5b349322ee4e6f575ff2254c7cf433-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":"<p><em><strong>참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음</strong></em></p>\n<h2 id=\"reliable-data-transfer\" style=\"position:relative;\"><a href=\"#reliable-data-transfer\" aria-label=\"reliable data transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reliable Data Transfer</h2>\n<ul>\n<li>TCP 와 같은 서비스는 신뢰적 데이터 전송을 보장한다.</li>\n<li>신뢰적 데이터 전송이란, 목적지 프로세스에 항상 모든 데이터가 순서대로 도착하고, 중간에 손실되는 데이터가 없음을 의미한다.</li>\n</ul>\n<h3 id=\"forward-error-correction-fec\" style=\"position:relative;\"><a href=\"#forward-error-correction-fec\" aria-label=\"forward error correction fec permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Forward Error Correction (FEC)</h3>\n<ul>\n<li>RDT를 위해서 목적지로 데이터를 보낼때, 중복되는 비트들을 보내는 방법으로 오류를 체크하는 방법이다.</li>\n<li>만약 1을 보낸다면 111을 보내고, 0을 보낸다면 000을 보내는 방식으로 중복된 값을 가진 비트를 더 추가해서 전송한다.</li>\n<li>\n<p>목적지에서는 이 비트를 확인하고 한 비트라도 다른 비트가 있다면 각 비트가 가진 더 많은 값을 선택해서 받는다.</p>\n<ul>\n<li>예를 들어 010이 도착했다면 0이 더 많은 값이기 때문에 값을 0으로 받고, 110 이 도착했다면 1이 더 많은 값이기 때문에 값을 1로 받는다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"retransmission---arqautomatic-repeat-request\" style=\"position:relative;\"><a href=\"#retransmission---arqautomatic-repeat-request\" aria-label=\"retransmission   arqautomatic repeat request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Retransmission - ARQ(Automatic Repeat Request)</h3>\n<ul>\n<li>수신자 측에서 오류를 판단하고 송신자에게 패킷의 재전송을 요청하는 방식이다.</li>\n</ul>\n<h4 id=\"stop-and-wait-arq\" style=\"position:relative;\"><a href=\"#stop-and-wait-arq\" aria-label=\"stop and wait arq permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stop and Wait ARQ</h4>\n<ul>\n<li>ARQ 중에서 가장 단순하고 구현이 쉬운 방식이다.</li>\n<li>단순하게 한 패킷이 목적지에 도착했을 때, 목적지는 해당 패킷을 잘 받았다는 <code class=\"language-text\">ACK</code> 패킷을 송신자에게 다시 보내고 송신자는 <code class=\"language-text\">ACK</code> 패킷을 받을 때까지 기다렸다가 다음 패킷을 보내는 방식이다.</li>\n<li>\n<p>이 방법을 사용하면 Flow Control 이 자동으로 된다는 장점이 있다. 왜냐하면 <code class=\"language-text\">ACK</code> 패킷을 받을 떄까지는 송신자는 절대 다음 패킷을 보내지 않기 때문에 송신자의 전송률이 수진자의 처리율보다 더 빨라도 부하가 걸리는 일이 없기 때문이다.</p>\n<ul>\n<li>하지만 단순히 ACK만 이용해서는 송신자가 데드락 상태에 빠질 가능성이 높다. ACK이 도착할 때까지 무한히 기다려야하기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p>따라서 Stop-and-wait에서는 <code class=\"language-text\">Time out</code> 개념을 도입해서 일정시간동안 송신자가 수신자로부터 ACK을 받지 못하면 Time out 이후에 같은 패킷을 다시 한 번 보내는(<code class=\"language-text\">Retransmission</code>) 구조를 사용한다.</p>\n<ul>\n<li>이 방법에서도 문제가 발생하는데, 다시 전송한 패킷이 이미 수신자 측에 있는 패킷이면 패킷의 중복 문제가 발생한다는 것이다.</li>\n</ul>\n</li>\n<li>이 중복문제를 해결하기 위해서 stop-and-wait 는 각 패킷에 <code class=\"language-text\">sequence number</code>를 붙여서 수진자 측에서 해당 번호를 확인한 뒤 중복된 패킷은 버리고 해당 패킷에 대한 ACK 만 응답하도록 한다.</li>\n<li>\n<p>그런데 만약 각 패킷을 보내는데 걸리는 시간이 다르다면, 다음과 같은 시나리오가 발생한다.</p>\n<ul>\n<li>송신자가 0번째 패킷을 보낸다.</li>\n<li>수진자는 0번째 패킷을 받고 ACK을 보낸다.</li>\n<li>그런데 그 사이에 time out이 되어 송신자는 0번쨰 패킷을 다시 보낸다.</li>\n<li>그 사이에 송신자는 0번째 패킷에 대한 ACK을 받고 1번째 패킷을 보낸다.</li>\n<li>다시 보낸 0번째 패킷이 이번에는 조금 빨리 도착해서 time out 전에 0번째 패킷에 대한 ACK을 송신자에게 보낸다.</li>\n<li>송신자는 자신이 마지막으로 보낸 패킷이 1번 패킷이므로, 1번에 대한 ACK이 도착했다고 생각한다.</li>\n</ul>\n</li>\n<li>그래서 우리는 ACK 패킷에도 수신한 패킷과 동일한 숫자를 부여해서 송신자에게 응답해야 위 같은 문제를 해결할 수 있다.</li>\n</ul>\n<h4 id=\"performance-of-stop-and-wait\" style=\"position:relative;\"><a href=\"#performance-of-stop-and-wait\" aria-label=\"performance of stop and wait permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Performance of Stop and Wait</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1116px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACfklEQVQ4y42Ua0/bUAyG+///yb5NmsQYKqwwroWW0qRN2/RK6f1GQ3pJTpJnPmkDaINplqyc+Dj2a792UlEUoSXodfHNAn4xT+gsSezJ8095f/9eU7ExDAntCuHtJcH5CaFlEG03/wz42V0qNikf1yoxuTxjkj7kpXhP9EH2jzQUMI7jxPqKUPketlFkMBzSGwyw7m75X1FKYZomI/lWB0+5rku1UiFzfEyz1WIgAY8zmdip025Tr9dpNBo71ef9u23bPPV6HB4ccCH+uVye1WpFSkcNA8XssYNhGPi+z3azoVAoxA66DN/zYiQqjFCCypezti+enynmc2ymEzxf7RC+Yl+7OMslFUEbsx4EmKUSngSLCZBE0WRM0KjpOlFyb4lvqMlbrxKWhBTdXJ31sQ3Pc5b9HuXsDZGMjjebUrq5Zi2BeHHwux2UngaxW3dZ3NGQaDxEzaevJL4h3KzfHdfUpUeJVCtWnD0R3VtHyo0lDMDbviHUvdHsDpsNBqMR/fGYyWJBrdni+9ERXWl8V+6/SfM77RZFIeuuWGQmY9KfzxmKf79Rxxai9DynAgk4WzpMri+YmEUmcjmuVVi0mtTSP+henbOtV8mdpCkL6odfp0wf8owKotkrRmcnTMsmdUGtY0nJ+1LcF7AtwvOfhKdpMPKoTpOnksHQrlG9z2MX7ulIQqom/tcvhBcZ6Hdhv1U7Uvarp5+hMOoXbvHyWUIhQbqDI3PqrDe4W49l2cATx0gY9nI3+JXSjgz97T5GKlmhOIGQoSyT4LG1w50QIXOKzFrUqsvojAhGg3jXIwEQg3n3o0h9uujJvursKxdVLRFIUNVuoGrWX3+bRH4Dy+t0mdlhNxwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"stop-and-wait-performance\"\n        title=\"stop-and-wait-performance\"\n        src=\"/static/dfc4f8eee4f85eac4484ed3de996cde7/ea64c/1.png\"\n        srcset=\"/static/dfc4f8eee4f85eac4484ed3de996cde7/5a46d/1.png 300w,\n/static/dfc4f8eee4f85eac4484ed3de996cde7/0a47e/1.png 600w,\n/static/dfc4f8eee4f85eac4484ed3de996cde7/ea64c/1.png 1116w\"\n        sizes=\"(max-width: 1116px) 100vw, 1116px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>stop-and-wait 의 성능평가는 다음처럼 이루어진다.</p>\n<ul>\n<li>패킷을 보낼 때와 ACK를 보낼 때 총 두 번의 propagation delay 가 소요된다 : <code class=\"language-text\">2tp</code></li>\n<li>송신측에서 패킷을 보낼 때와 수신측에서 ACK을 보낼 때 두 번의 다른 transmission time이 소요된다 : <code class=\"language-text\">L+A / R</code></li>\n<li>따라서 전체 사이클을 한번 도는데 걸리는 시간은 <code class=\"language-text\">(L+A)/R + 2tp</code> 이다.</li>\n<li>하지만 실제 Utilization은 <code class=\"language-text\">L/(L+A+2Rtp)</code> 로 계산된다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"sliding-window-protocols--pipelining\" style=\"position:relative;\"><a href=\"#sliding-window-protocols--pipelining\" aria-label=\"sliding window protocols  pipelining permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sliding Window Protocols : Pipelining</h4>\n<ul>\n<li><code class=\"language-text\">Sliding window</code> 는 파이프라이닝을 사용해서 아직 ACK이 송신측에 도착하지 않았다고 하더라고 일정한 양의 패킷을 연달아 보내는 정책이다.</li>\n<li>기존 stop-and-wait은 한번에 한 패킷만 처리하기 때문에 sequence number 에 많은 비트 수를 할당 할 필요가 없었지만 이 경우에는 한번에 많은 패킷을 보내기 때문에 sequence number 에도 많은 비트 수를 할당해야한다.</li>\n</ul>\n<h4 id=\"go-back-ngbn\" style=\"position:relative;\"><a href=\"#go-back-ngbn\" aria-label=\"go back ngbn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Go-Back-N(GBN)</h4>\n<p><img src=\"https://www.net.t-labs.tu-berlin.de/teaching/computer_networking/03.04-Dateien/gbn_seqnum.gif\" alt=\"GBN\"></p>\n<p><img src=\"https://3.bp.blogspot.com/-pn9sAS_zSas/WX8Lqv6DetI/AAAAAAAABVY/r1FiR4vuQwgCGY8QvnyxaB6zPUS3FgeuACLcBGAs/s640/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%2B2017-07-31%2B%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%2B7.50.57.png\" alt=\"GBN-example\"></p>\n<ul>\n<li>GBN은 sliding window 정책을 사용하는 하나의 방법이다.</li>\n<li>\n<p>송신측 동작 원리</p>\n<ul>\n<li>송신자 측은 window의 크기로 N을 지정할 수 있는데, 이 N은 한번에 송신자 측이 전송할 패킷의 개수를 의미한다.</li>\n<li><code class=\"language-text\">send_base</code>는 아직 ACK 응답을 받지 않은 패킷들 중에 가장 첫 패킷을 말한다. 따라서 송신측은 send<em>base 부터 send</em>base + N - 1 번 까지의 패킷 중 아직 보내지 않은 패킷을 보내게 된다.</li>\n<li>각 패킷은 타이머를 사용해서 <code class=\"language-text\">time out</code> 서비스를 제공한다.</li>\n<li>만약 n 패킷에 대한 time out 이 발생하면 n 패킷을 포함해서 해당 패킷 이전에 window에 있는 모든 전달된 패킷을 다시 수신자 측에게 보낸다.</li>\n</ul>\n</li>\n<li>\n<p>수신측 동작 원리</p>\n<ul>\n<li>수신자 측은 <code class=\"language-text\">window를 항상 1</code>로 설정한다. 따라서 수신측은 현재 받고자 하는 패킷의 sequence number 만을 기억한다.</li>\n<li>만약 수신을 기다리고 있던 sequence에 맞는 패킷이 전달되면 연속적으로 전돨된 sequence number중 가장 큰 숫자를 ACK에 붙여 송신자에게 보낸다. 이때, 이 ACK은 <code class=\"language-text\">cumulative ACK</code> 이라고 하고, 해당 ACK이 가진 sequence number 이전의 숫자를 가진 모든 패킷들은 정상적으로 도착했다는 것을 의미한다.</li>\n<li>만약 수신을 기다리고 있던 sequence와 일치하지 않는 패킷이 전달되면 순서가 잘못된 패킷이라고 판단하고 해당 패킷을 <code class=\"language-text\">버린다</code>. 그리고 지금 가지고 있는 연속된 sequence number 중 가장 큰 숫자를 ACK에 붙여 보낸다. 이렇게 하면 현 시점에서 <code class=\"language-text\">성공적으로 받은 마지막 패킷의 숫자를 송신자에게 알려주게 된다</code>.</li>\n</ul>\n</li>\n<li>\n<p>윈도우의 크기는 sequence number 로 사용하는 비트 수에 영향을 받는다. 윈도우가 너무 크면 일정 비트의 sequence number로 표현할 수 없는 문제가 발생한다.</p>\n<ul>\n<li>따라서 윈도우의 크기는 항상 <code class=\"language-text\">2^m - 1</code>보다 같거나 작아야한다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"selective-repeat-sr\" style=\"position:relative;\"><a href=\"#selective-repeat-sr\" aria-label=\"selective repeat sr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Selective Repeat (SR)</h4>\n<ul>\n<li>Selevtive Repeat은 GBN과 비슷하지만 수신자 측에도 송신자와 동일한 크기의 window를 만들어 사용하는 정책이다.</li>\n<li>\n<p>송신측 동작원리</p>\n<ul>\n<li>GBN과 마찬가지로 SR도 <code class=\"language-text\">send_base ~ send_base + N - 1</code> 의 sequence number를 가진 패킷을 전달한다.</li>\n<li>하지만 GBN과는 다르게 ACK이 되지 않은 패킷들만 재전송하는 정책을 가진다.</li>\n</ul>\n</li>\n<li>\n<p>수신측 동작원리</p>\n<ul>\n<li>만약 수신측 윈도우에 포함되는 번호를 가진 패킷이 전달되면, 해당 패킷을 받고 ACK을 보낸다. 이때, 전달받은 패킷이 순서에 어긋나더라도 저장한다.</li>\n<li>순서에 어긋난 패킷은 별도의 버퍼에 따로 저장을 해두고 상위 계층에는 아직 전달하지 않는다.</li>\n<li>새로운 패킷이 전달되고 해당 패킷의 순서가 버퍼에 있는 패킷들과 함께 올바른 순서가되면 모든 패킷들을 상위 계층에 전달한다.</li>\n</ul>\n</li>\n<li>\n<p>SR도 GBN 과 같이 윈도우 크기와 sequence number 의 비트수가 서로 연관되어 있다.</p>\n<ul>\n<li>윈도우의 크기는 항상 <code class=\"language-text\">2^m - 1</code>보다 같거나 작아야한다.</li>\n</ul>\n</li>\n</ul>"}