{"expireTime":9007200877354311000,"key":"transformer-remark-markdown-html-2e07d62361e56056cc1b393f6f13179f-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-images-medium-zoomgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-autolink-headersgatsby-remark-emoji-","val":"<h2 id=\"divide-and-conquer\" style=\"position:relative;\"><a href=\"#divide-and-conquer\" aria-label=\"divide and conquer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Divide and Conquer</h2>\n<p>Divide and Conquer, 분할정복은 큰 문제를 여러 개의 작은 문제로 쪼개고 쪼개서 해결하는 방법이다. 일반적으로 Divide and Conquer는 recurrence equation으로 표현할 수 있는데, 우리는 이 수식을 통해서 알고리즘의 time complexity 를 구할 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 734px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAAA40lEQVQoz4VRywqEMAzs/3+SV8HHVTwIIgrq4ltEXd/tzhoUu4I7h9ImmSQzZVmWCSE45zjnee77XuzAfRxHIaNpmmVZyrLsug5P5rruSR6Goa5rqkuSJAiCM0UX27bjOI6iqG3bL/na+CTzA9fsPcJeO7DPtm3Yuaqq67RnMM/zFEXRNC3P8zRNSfP7wB8yBsIb2IBp0zSFYeg4DtRCHnohCNvIHmqKejzJS0nzuq66rquqii1gKTwrisIwDASRBc2yLBjm+z5ZI5HRGNWYhv8zTRNegPCgXyJjedJJzt3/+QcfuloILReT+J0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eq1\"\n        title=\"eq1\"\n        src=\"/static/10b571ec9f5217ccb32c37fc96e3aad2/c6d67/eq1.png\"\n        srcset=\"/static/10b571ec9f5217ccb32c37fc96e3aad2/5a46d/eq1.png 300w,\n/static/10b571ec9f5217ccb32c37fc96e3aad2/0a47e/eq1.png 600w,\n/static/10b571ec9f5217ccb32c37fc96e3aad2/c6d67/eq1.png 734w\"\n        sizes=\"(max-width: 734px) 100vw, 734px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위와 같은 식을 우리는 recurrence equation 이라고 한다. 식을 보면 T(n) 이 T(n/2) 로 작아지는 것을 볼 수 있다. 이런식으로 n 은 재귀를 거듭할때마다 작아질 것이다.</p>\n<p>이런 recurrence equation을 통해 알고리즘을 분석하는 방법은 네 가지가 있다.</p>\n<h2 id=\"substitution-method\" style=\"position:relative;\"><a href=\"#substitution-method\" aria-label=\"substitution method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Substitution method</h2>\n<p>첫번째 방법은 substitution method이다. 이 방법을 사용하려면 사실 어느정도 알고리즘에 숙련되어 있어야한다. 왜냐하면 분석의 첫 시작을 solution 의 form 을 추측하는 것으로 시작하기 때문이다. 주어진 수식을 보고 어떤 알고리즘일 것이다라고 가정을 세우고 그것이 맞는지 확인해가는 작업을 거친다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1074px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAABWElEQVQ4y5WTba9DQBCF/f9fR0IalJag9VLqtUVpn3Sbe8UldefDZszumTPn7JKeSzEMQ9/3YRiWZclnVVV8Nk1T1/X0mPSTjePImmWZ53mczvPcNM00TSmSd13HWhTFHCxgImifJAmEu93Otm3IqYBp23YZvDj24/G43+/TvjOaD5hRfd+HkBxtQRBQiePYdV3HcYTsGewXfLlcdF0HM7yDUZEKGPHg0S+ail26MBTJB8z24XCAZL/fG4bBalkWeNohEttojX7qqqpyjDNC/Mew/h20pEovRkVFFEW4hc/UOSOMEPmCYVRhO5/PrJBDgniaPldCWtuA/3q9Tnm+g4WE4/EIraIoTIGda/gFZo7yJLg8kHh+u92QvRWMMWA0TcMzaGnB2/oHGJ8Bn04nEvzHPF7bJjCagcmyzMpvBBLbuHbxBL9r5nq5JNQyhXhh5H/JV69qS7wA3kfa8q5AHOoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"sub method\"\n        title=\"sub method\"\n        src=\"/static/a70710c37462704c4493c7507e4bc772/18539/sub_method.png\"\n        srcset=\"/static/a70710c37462704c4493c7507e4bc772/5a46d/sub_method.png 300w,\n/static/a70710c37462704c4493c7507e4bc772/0a47e/sub_method.png 600w,\n/static/a70710c37462704c4493c7507e4bc772/18539/sub_method.png 1074w\"\n        sizes=\"(max-width: 1074px) 100vw, 1074px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 예시를 보자. 나는 왜인지 전혀 모르겠지만, 저자는 2T(n/2)+n 을 보고 O(nlogn) 의 복잡도를 가지지 않을까라는 가정을 세운다. 그리고 그것을 증명하기 위 nlogn을 기존 수식에 대입하여 풀고 가설이 사실이라는 것을 증명했다.</p>\n<h2 id=\"recursion-tree-method\" style=\"position:relative;\"><a href=\"#recursion-tree-method\" aria-label=\"recursion tree method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursion Tree Method</h2>\n<p>Recursion Tree Method는 수식을 단계별로 트리모양으로 만들어 복잡도를 계산하는 방법이다. 이 방법은 세 단계로 진행되는데,</p>\n<ol>\n<li>Build a recursion tree.</li>\n<li>Sum the costs within each level.</li>\n<li>Sum the costs of all levels.</li>\n</ol>\n<p>로 나눌 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAAA3klEQVQoz3WS2w6DMAxD+/8fyRNCgEDjTqFQdsCsQp2wtCpJ69jJMMcfhmHI87yqqiRJyrLsuu54geHnvX+WSJdlmed5HEdr7bZtEWffd+fcTe77fl3X6JrimyCPaXqTp2lSezhcoEyKuFxgIRLnmW4NPRAhV5e2bdW7aRo9pRL5ImWik5ymaVEURLS3F+gaAg1PrCEDmSKmbttEnJ8LSLFhnWyeABcEYbUwZdDovwkzC6SanNhf0FwCdcQRO8kMgD0pAG1SHA2PHc7gvK7rLMuomNDP/fAUgR/q0ecAvhilSvlcUabeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"recur tree\"\n        title=\"recur tree\"\n        src=\"/static/cc2972597bb3867e48a0d5d6a7b7ff79/c1b63/recur_tree.png\"\n        srcset=\"/static/cc2972597bb3867e48a0d5d6a7b7ff79/5a46d/recur_tree.png 300w,\n/static/cc2972597bb3867e48a0d5d6a7b7ff79/0a47e/recur_tree.png 600w,\n/static/cc2972597bb3867e48a0d5d6a7b7ff79/c1b63/recur_tree.png 1200w,\n/static/cc2972597bb3867e48a0d5d6a7b7ff79/eb1d2/recur_tree.png 1622w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 예를 보면, 3T(n/4) 이기 때문에 총 세 개의 c(n/4)를 만들수 있고 이런식으로 계속 노드를 아래로 늘려가다보면 T(1)이 되는 노드들이 나올 것이다. 이렇게 하면 일단 1단계인 recurstion tree를 만드는 것은 완료이다.</p>\n<p>이제 2단계인 각 level의 cost를 구해야하는데, 그림의 오른쪽에 보다시피 우리가 구한 노드들의 n을 나열해보면 1/4^n 씩 늘어나는 것을 알 수 있다. 따라서 높이를 h로 두었을 때 마지막 노드는 1/4^h n 으로 나타낼 수 있다. 이것을 h에 대해서 정리하면, 우리는 이 트리에 높이를 log<sub>4</sub>n으로 표현할 수 있을 것이다.</p>\n<p>각 레벨의 노드의 개수는 3의 거듭제곱씩 늘어나기 때문에 제일 아래에 위치한 노드들의 갯수는 3<sup>log<sub>4</sub>n</sup> 이 되고 이것을 로그의 성질에 따라 정리하면 n<sup>log<sub>4</sub>3</sup> 으로 나타낼 수 있다.</p>\n<p>따라서 3단계에 따라 모든 cost들의 합을 계산하면 cn<sup>2</sup> 부터 (3/16)<sup>log<sub>4</sub>n-1</sup>cn<sup>2</sup> + 𝛩(n<sup>log<sub>4</sub>3</sup>) 의 합을 구하면 되고 이는 등비수열에 해당하기 때문에 공식을 따라서 계산하면 된다. 그러면 그 결과로 우리는 T(n)이 𝛩(n<sup>2</sup>)의 복잡도를 가지는 것을 확인할 수 있다.</p>\n<h2 id=\"iteration-method\" style=\"position:relative;\"><a href=\"#iteration-method\" aria-label=\"iteration method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Iteration method</h2>\n<p>iteration method 는 우리가 가진 재귀 수식으로 새로운 수식을 만들어 나가는 방식으로 문제를 해결하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABK0lEQVQoz52S626DMAyFef8nBEahhY1LQhICKQm5sdOi/VgnVe2Oosiy8tmO7SRNU+/9/kf+LnsXDErp4TfGjOPY9z2cSdcTbb1xYbXe+RBjxIsQQp7nRVFwzpVS1+t1GAZgMLZtm6ap67obzHXoFpcS3UgnTTzCI4RzDjcAvGvbFoHAICcKIXchQcI544wJMVEynM/nuq6P5K8oATbJGZURQi91gyQPcPzRg+cGF2xjOlbC5qM9Cb+/o+Tzq5PzwuUiZtX2BG2UUh7hX4CbhrNRcqZmeSo+qqpCV16FS77RNVyEzaiphHuvbGWcsUFqh7NohwHE33oG7zHs/1VSjYqtrub6IsyJKKxUWZb4NmaeZdnz/ydksasNuNnVUdjrik3UWmPgWKPnnf8GeEz0OuRPOYgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"iter method\"\n        title=\"iter method\"\n        src=\"/static/a7b79460e3a69b8dea58cd57c2f8d51f/c1b63/iter_method.png\"\n        srcset=\"/static/a7b79460e3a69b8dea58cd57c2f8d51f/5a46d/iter_method.png 300w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/0a47e/iter_method.png 600w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/c1b63/iter_method.png 1200w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/d61c2/iter_method.png 1800w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/191e2/iter_method.png 1836w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 예시를 보자. s(n) = c + s(n-1) 의 식이 성립하기 때문에, 우항의 s(n-1)은 c + s(n-2) 로도 나타낼 수 있다. 이런식으로 식을 반복적으로 만들어보면 우리는 ck + s(n-k) 라는 정규화된 식을 도출 할 수 있다.</p>\n<p>초기식에서 우리는 s(0) = 0 이라는 정보를 가지고 있고, k는 항상 n보다 같거나 작아야 한다. 따라서 k가 n 과 같다고 가정했을 때, 우리는 최종적으로 s(n) = cn 이라는 식을 도출 할 수 있고, 최종적으로 이 수식의 시간복잡도는 O(n) 이라고 결론내릴 수 있게 된다.</p>\n<h2 id=\"master-method\" style=\"position:relative;\"><a href=\"#master-method\" aria-label=\"master method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Master Method</h2>\n<p>Master method 는 재귀식을 특정한 형태로 만들고, 그 형태 안에서 정보를 얻어 준비되어 있는 조건에 맞는지 확인하는 방법이다. 하지만 모든 재귀식이 이 조건으로 판단 될 수는 없고 주어지는 세 가지 조건에 모두 해당하지 않는 재귀식이 있을 수 있다.</p>\n<p>Master theorem 은 다음과 같다.</p>\n<p>a >= 1, b > 1, 함수 f(n) > 0 이고 T(n) 이 양수로 정의된다면,</p>\n<center>\n<br>T(n) = a T(n/b) + f(n)\n</center>\n<br>\n위 수식의 T(n)은 아래의 조건에 따라 구분될 수 있다.\n<ol>\n<li>f(n) = Օ(n<sup>log<sub>b</sub>a-ε</sup>) 의 형태를 가질 때, ε이 0보다 크다면, T(n)의 복잡도는 <strong>T(n) = 𝛩(n<sup>log<sub>b</sub>a</sup>)</strong> 이다.</li>\n<li>f(n) = 𝛩(n<sup>log<sub>b</sub>a</sup>) 의 형태를 가질 때, T(n)의 복잡도는 <strong>T(n) = 𝛩(n<sup>log<sub>b</sub>a</sup> lg n)</strong> 이다.</li>\n<li>f(n) = Ω(n<sup>log<sub>b</sub>a+ε</sup>) 의 형태를 가질 때, ε이 0보다 크고, 1보다 작은 c에 대해 f(n) 이 f(n/b) ≤ cf(n)의 조건을 만족한다면, T(n)의 복잡도는 <strong>T(n) = 𝛩(f(n))</strong> 이다.</li>\n</ol>\n<h2 id=\"proof-by-induction\" style=\"position:relative;\"><a href=\"#proof-by-induction\" aria-label=\"proof by induction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof By Induction</h2>\n<p>수학적 귀납법을 통해 알고리즘을 분석하는 방법이다. 수학적 귀납법은 크게 1) Base case, 2) Inductive hypothesis, 3) Proof of goal statement 의 세 단계로 이루어져 있다.</p>\n<ol>\n<li>Base case:\n이 단계에서 우리는 가지고 있는 방정식이 n=0 이거나 n=1 일 때 성립하는지 확인한다.</li>\n<li>Inductive hypothesis:\n귀납법을 수행하기 위해서 가정을 세워야 한다. Base case 를 기준으로 가설을 세우면, 0보다 큰 모든 n에 대해서 우리가 가진 방정식이 k ≥ 0 와 k &#x3C; n 을 만족한다는 가정을 세울 수 있다. 따라서, 이 가정에 따라 방정식은 k=n-1 일 때도 성립할 것이다.</li>\n<li>Proof of goal statement:\n이 단계에서는 우리가 세운 가정에 따라 방정식이 실제로 성립하는지 확인하는 작업을 가져야한다.</li>\n</ol>\n<p>귀납법을 이용한 방법은 항상 쉽지 않다. 왜냐하면 중간단계에서 세우는 가정이 조금만 틀리면, 그럴듯 해보이지만 반례가 존재하는 가정이 만들어지고 실제로는 false 이지만 true인 명제라고 착각하기가 쉽기 때문이다. 아래 예를 통해 더 자세히 알아보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAAB20lEQVQoz31Sia6bMBDk/z8uDeII5TAQDE6MucVlAu4AfVQ91FW02tjenZ0ZtG/3u25Z4fP5zLK3EI7j5Hn+eDzqupZSVlXleZ4QwrZtXPm+f7vdUERRFIahJqdpiCKZZaptF8aWaVrX9XPEtm1XMY7jNE3zPA/DgCyP0NQ8qyCQhjEHwceyZNctCCk/e5LLV8ZE9VdoatsWpZKqcpOkGIa676M0zYRo+p4xlmVZQMj7/QaXswFbXPknsrJt5TiKEBWGyjDwdw2C88V/YkeWTVNR2jJWUioIEVEk4rjjvDoCahVF0XVd27ZnxlDIiVrDgHXbYko9Qkzb1k0zjGPDtr/7vq7rkN00zSAIKKWEECgMWzCraRpIqJ0EcMc5T5IkTVMwRIYZIIwCzPH6ugJ5tJ367c0QExdhFLnw1HXjOEYDQMiBg3BdF+CYBQqw6tJCOyscVWVZNw3IwE/YA6JlWYIhoND/er34ocIl9YE8jsr3918cK8vaNfc8db/vJ3DhX/b+pvYE2DwvOF+GYeo6jvUYq4CDw6KojwBJ7Ax2WAT4vzhDALzalYEeRUHTVJQl1uZCZIxBKuiEKejp+x6PQerrIzkEw2wwRDtewAZ4CBWKgzY6cXhq8cfaPwCPpBHNPFxcswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proof induction\"\n        title=\"proof induction\"\n        src=\"/static/ec63514bc5c17787c0767ae3e76ddc15/c1b63/proof_induction.png\"\n        srcset=\"/static/ec63514bc5c17787c0767ae3e76ddc15/5a46d/proof_induction.png 300w,\n/static/ec63514bc5c17787c0767ae3e76ddc15/0a47e/proof_induction.png 600w,\n/static/ec63514bc5c17787c0767ae3e76ddc15/c1b63/proof_induction.png 1200w,\n/static/ec63514bc5c17787c0767ae3e76ddc15/41870/proof_induction.png 1788w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>"}