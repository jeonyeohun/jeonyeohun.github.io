{"componentChunkName":"component---src-templates-blog-post-js","path":"/Operating-Systems/2020-06-09-운영체제-메인-메모리-구조/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.netlify.app","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"3b2a1fca-617f-565d-bfa7-9df497f878a5","excerpt":"참고도서: Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne 메인 메모리 컴퓨터 시스템 안에서 CPU…","html":"<p>참고도서: <em>Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne</em></p>\n<h2 id=\"메인-메모리\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%9D%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"메인 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메인 메모리</h2>\n<p>컴퓨터 시스템 안에서 CPU가 직접적으로 접근할 수 있는 저장장치는 각 코어 안에 내장된 캐시와 메인메모리 뿐이다. 메인메모리 없는 컴퓨터는 시체나 다름없는데(사실 다른 주요장치들도 없으면 안되지만), 이 메인메모리가 어떻게 구성되고 관리되는지 공부해보자</p>\n<h2 id=\"기준-레지스터와-상한-레지스터\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%A4%80-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0%EC%99%80-%EC%83%81%ED%95%9C-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0\" aria-label=\"기준 레지스터와 상한 레지스터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기준 레지스터와 상한 레지스터</h2>\n<p>운영체제와 프로세스는 모두 메모리에 적재되어서 실행되어진다. 따라서 메모리 내에서 영역을 정확하게 구분하는 것이 필수적으로 요구된다. 운영체제는 그렇다 치고, 만약 어떤 프로세스가 메모리 여기저기에 데이터를 쓰고 다닌다면… 상상만해도 끔찍쓰..</p>\n<p>이렇게 각 프로세스마다 명확한 공간을 분리하기 위해서 <code class=\"language-text\">기준 레지스터(base register)</code> 와 <code class=\"language-text\">상한 레지스터(limit register)</code> 를 사용하게된다. 기준 레지스터는 어떤 프로세스가 시작되는 가장 첫 시작주소를 가지고, 상한 레지스터는 해당 프로세스가 최대로 사용할 공간을 가진다. 따라서 이 프로세스는 기준 주소부터 <code class=\"language-text\">기준+상한</code> 주소까지의 메모리 공간을 사용하고 보호받게 되는 것이다. 만약 어떤 프로세스의 연산이 다른 프로세스의 영역을 침범하게 된다면, 운영체제는 이 접근을 허용하지 않고 트랩을 통해서 동작을 정지시킨다.</p>\n<h2 id=\"논리-공간과-물리-주소공간\" style=\"position:relative;\"><a href=\"#%EB%85%BC%EB%A6%AC-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EB%AC%BC%EB%A6%AC-%EC%A3%BC%EC%86%8C%EA%B3%B5%EA%B0%84\" aria-label=\"논리 공간과 물리 주소공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>논리 공간과 물리 주소공간</h2>\n<p>CPU가 연산을 진행하며 생성하는 주소는 메모리에서 사용하는 주소와 다르다. 우리는 CPU에서 생성되는 주소를 <code class=\"language-text\">논리 주소(Logical address)</code> 라고 하고, 메모리에서 사용하는 주소를 <code class=\"language-text\">물리 주소(Physical address)</code> 라고 한다. 이것은 CPU에서 생성된 주소로 메모리에 접근하면 원하는 결과를 얻을 수 없다는 것을 의미한다. 따라서 CPU와 메모리 사이에서 논리 주소를 물리 주소로 변환시켜주는 작업을 하는 장치가 필요하다.</p>\n<p>이 장치를 우리는 <code class=\"language-text\">메모리 관리 장치(MMU)</code> 라고 부른다. MMU는 다양한 방법을 통해서 논리 주소를 물리 주소로 변환하는데, 가장 간단한 방법이 <code class=\"language-text\">재배치 레지스터(relocation register)</code>를 사용하는 것이다. 재배치 레지스터의 역할은 앞서 설명했던 기준 레지스터의 역할과 비슷하다. 이 레지스터는 각 프로세스의 어떤 특정한 값을 가지고 CPU에서 논리 주소가 들어올 때마다 이 값을 논리 주소에 더해서 물리 주소를 만들어낸다. 예를 들어, CPU에서 생성한 주소가 30 이고 재배치 레지스터의 값이 300 이라면, CPU는 메모리 주소 330번지에 있는 데이터에 접근하게 되는 것이다.</p>\n<p>이렇게 논리 주소를 물리주소로 변환해서 CPU가 바로 메모리에 접근할 수 없게 하는 것의 이점은 메모리 내의 프로세스의 위치가 달라져도 CPU는 항상 같은 논리 주소로 해당 프로세스에 접근할 수 있다는 것이다.</p>\n<h2 id=\"메모리-할당\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9\" aria-label=\"메모리 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 할당</h2>\n<p>프로그램이 프로세스가 되어 메모리에 적재될 때, 가장 간단한 방법은 <code class=\"language-text\">가변 파티션(Dynamic partitioning)</code> 이다. 단순하게 새로 메모리에 올라온 프로세스를 사용가능한 공간에 적재시키는 것이다. 이렇게 메모리를 관리하게 되면, 사용가능한 메모리 영역이 구분되게 되는데 이런 공간을 <code class=\"language-text\">hole</code>이라고 한다. 유의할 점은 hole이 단순하게 모든 사용가능한 공간의 합을 의미하지 않는다는 것이다. 만약 연속된 메모리 공간에 프로세스 1, 프로세스 2, 프로세스 3 이 적재되어 있을 때, 프로세스 2의 작업이 끝나고 메모리에세 제거 되면, 메모리에는 프로세스 1의 공간과 프로세스 3의 공간 사이에 있는 hole, 그리고 프로세스 3 이후의 있는 빈 공간들로 총 두 개의 hole이 존재하게 된다.</p>\n<p>여기서 한가지 문제점이 발생한다. 프로세스가 계속해서 메모리에 적재되고 해제되다 보면 수많은 hole이 생겨날텐데, 새로 들어온 프로세스는 이들 중 어디에 적재시켜야 할까? 이 문제를 해결하기 위해 세 가지 방법이 제안된다.</p>\n<ol>\n<li><code class=\"language-text\">최초 적합(First-fit)</code>: 메모리의 시작점 혹은 끝 지점부터 순서대로 탐색하면서, 새 프로세스를 적재할 수 있는 크기를 가진 hole이 등장하면 곧바로 프로세스를 적재시킨다.</li>\n<li><code class=\"language-text\">최적 적합(Best-fit)</code>: 메모리에 있는 모든 hole을 다 확인해서 사용가능한 hole 중 새 프로세스와 크기가 가장 가까운 hole에 프로세스를 적재시킨다. 단점은 모든 hole들을 다 탐색해야하기 때문에 오버헤드가 발생하게 된다.</li>\n<li><code class=\"language-text\">최악 적합(Worst-fit)</code>: 메모리에 있는 모든 hole을 다 확인해서 사용가능한 hole 중 크기가 가장 큰 hole에 프로세스를 적재한다. 이떄 프로세스를 적재하고 남은 크기는 다시 또 새로운 hole 이 된다. 이 방법 역시 메모리 내의 모든 hole을 다 검사해야하는 오버헤드가 발생한다.</li>\n</ol>","frontmatter":{"title":"[운영체제] 메인 메모리의 구조","date":"June 09, 2020"}}},"pageContext":{"slug":"/Operating-Systems/2020-06-09-운영체제-메인-메모리-구조/","previous":{"fields":{"slug":"/Operating-Systems/2020-06-09-운영체제-빌드과정/"},"frontmatter":{"title":"[운영체제] 소스코드가 빌드되는 과정","category":"Operating-Systems","draft":false}},"next":{"fields":{"slug":"/Operating-Systems/2020-06-10-운영체제-메모리-단편화와-페이징/"},"frontmatter":{"title":"[운영체제] 메모리 단편화와 페이징(Memory fragmentation and Paging)","category":"Operating-Systems","draft":false}}}}}