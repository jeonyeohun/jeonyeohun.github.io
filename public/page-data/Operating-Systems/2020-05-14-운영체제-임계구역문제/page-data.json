{"componentChunkName":"component---src-templates-blog-post-js","path":"/Operating-Systems/2020-05-14-운영체제-임계구역문제/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.netlify.app","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"c48ed8ea-a54c-5195-bfbf-acb2716827ab","excerpt":"참고도서: Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne…","html":"<p>참고도서: <em>Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne</em></p>\n<p>여러 프로세스가 동시에 작업을 수행할 때, 이 프로세스들 사이에 데이터의 공유가 있을 수 있다. 앞선 수업들에서 정리했던 것 처럼, 공유 메모리나 메세지를 전달하는 방식으로 말이다. 그런데 만약 데이터에 두 프로세스나 스레드가 동시에 접근해서 데이터를 수정하려고 하면 어떨까? 이런 상황을 <code class=\"language-text\">Race Condition(경쟁 상황)</code> 이라고 하는데, 경쟁 상황이 잘 제어되지 못하는 시스템은 심각한 문제를 초래할 것이다. 특히 최근의 컴퓨터 시스템은 기본적으로 SMP나 멀티 스레딩을 지원하므로 이런 동기화 이슈들을 잘 해결하는 것은 매우 중요한 일이다.</p>\n<p>아래 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">consumer</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">producer</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이전에 살펴보았던 소비자-생산자 이슈를 다시 살펴봤을 때, 만약 두 프로세스나 스레드가 이 함수들을 병렬적으로 처리한다면, 연산의 결과는 상황에 따라 달라지게 된다. <code class=\"language-text\">count</code> 변수가 증가함과 동시에 감소할 수도 있고, 증가만 할 수도 있고, 감소만 할 수도 있기 때문이다.</p>\n<h2 id=\"critical-section-problem\" style=\"position:relative;\"><a href=\"#critical-section-problem\" aria-label=\"critical section problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Critical-Section Problem</h2>\n<p>Critical-Section은 <code class=\"language-text\">임계 구역</code> 이라고도 불리는데, 이 구역은 어떤 코드의 영역에서 다른 프로세스와 데이터를 공유하는 부분을 말한다. 프로세스가 처리하는 코드는 임계구역을 기준으로 다음과 같이 크게 세 구간으로 나누어진다.</p>\n<ul>\n<li><code class=\"language-text\">Entry Section(진입 구역)</code>: 임계 구역으로 진입하기 위해 진입 허가를 요청하는 구역</li>\n<li><code class=\"language-text\">Exit Section(퇴출 구역)</code>: 임계 구역이 끝난 직후 따라오는 코드 구역</li>\n<li><code class=\"language-text\">Remainder Section(나머지 구역)</code>: 진입 구역, 퇴출 구역, 임계 구역을 제외한 나머지 코드 부분</li>\n</ul>\n<h3 id=\"criteria-of-solution\" style=\"position:relative;\"><a href=\"#criteria-of-solution\" aria-label=\"criteria of solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Criteria of Solution</h3>\n<p>결국 우리가 해결해야할 문제는 이 임계구역에 여러 프로세스들이 접근해서 데이터를 수정하려고 할 때, 어떻게 반응해야할 것인지에 대한 부분이다. 그리고 임계구역 문제를 해결하기 위해서는 다음과 같은 세 요구조건이 충족되어야 한다.</p>\n<ol>\n<li><code class=\"language-text\">Mutual Exclusion(상호 배제)</code>: 어떤 프로세스가 자신의 임계 구역에서 작업을 수행하고 있다면 다른 프로세스들은 이 프로세스의 임계구역에 진입할 수 없다.</li>\n<li><code class=\"language-text\">Progress(진행)</code>: 임계구역에서 작업 중인 프로세스가 없다면 임계구역으로 진입하려는 프로세스의 진입결정은 유한시간 내에 결정되어야 한다.</li>\n<li><code class=\"language-text\">Bounded Waiting(한정된 대기)</code>: 어떤 프로세스가 자신의 임계 구역에 진입하려고 할 때, 다른 프로세스가 임계구역을 사용하고 있다면, 임계 구역을 사용 중인 프로세스는 해당 임계구역 진입 횟수에 한계가 있어야 한다.</li>\n</ol>\n<p>쉽게 말하면 임계구역은 한번에 한 프로세스만 진입해야 하고, 진입의 결정을 다른 프로세스에 의해 할 수 있으며, 한 프로세스가 계속해서 임계구역을 점유하고 있을 수는 없다는 것이다.</p>\n<h2 id=\"solution-in-operating-system\" style=\"position:relative;\"><a href=\"#solution-in-operating-system\" aria-label=\"solution in operating system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution in Operating System</h2>\n<p>운영체제는 임계 구역 문제를 해결하기 위해서 두 종류의 접근을 커널을 설계하는 시점에서 계획한다.</p>\n<ol>\n<li><code class=\"language-text\">Preemptive Kernel(선점형 커널)</code>: 프로세스가 커널 모드에서 실행 중일 때, 다른 프로세스에 의해 선점되는 것을 허용한다. 이때, 프로세스들 사이에 경쟁 조건이 발생할 수 있고, 커널모드에서의 경쟁조건이 정상적으로 해결되지 못한다면 시스템 전체에 안좋은 영향을 줄 수 있기 때문에, 경쟁 조건에 대한 대처가 정교하게 잘 설계되어 있어야한다.</li>\n<li><code class=\"language-text\">Non-Preemptive Kernel(비선점형 커널)</code>: 프로세스가 커널 모드에서 실행 중일 때, 다른 프로세스는 CPU를 점유중인 프로세스가 종료되어 할당이 해제되거나, 인터럽트에 의해 봉쇄될 때까지 다른 프로세스에 의해 선점되는 것을 허용하지 않는다.</li>\n</ol>\n<p>비선점형 커널은 어차피 한번에 한 프로세스의 접근만이 허용되기 때문에 경쟁 조건이 발생할 리스크가 없다. 그렇지만 대부분의 운영체제에서는 선점형 커널이 선호되는데, 선점형 커널은 한 프로세스가 지나치게 오랫동안 CPU를 점유하고 있는 것을 방지해 빠른 성능을 보이기 때문이다.</p>\n<h2 id=\"pertersons-solution-피터슨의-해결안\" style=\"position:relative;\"><a href=\"#pertersons-solution-%ED%94%BC%ED%84%B0%EC%8A%A8%EC%9D%98-%ED%95%B4%EA%B2%B0%EC%95%88\" aria-label=\"pertersons solution 피터슨의 해결안 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Perterson’s Solution (피터슨의 해결안)</h2>\n<p>피터슨의 해결안은 임계구역 문제를 해결하기 위한 하나의 알고리즘이고 다음과 같은 구조를 지닌다. 예를 들어 두개의 프로세스 i와 j가 있다고 하자</p>\n<ul>\n<li>프로세스 i</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    turn <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> turn <span class=\"token operator\">==</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Critical Section  */</span>\n\n    flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n    <span class=\"token comment\">/* Remainder Section */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>프로세스 j</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    turn <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> turn <span class=\"token operator\">==</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Critical Section  */</span>\n\n    flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n    <span class=\"token comment\">/* Remainder Section */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 둘 사이에 Peterson 해결안을 위한 공유 데이터 turn 과 flag 가 있다고 하자.</p>\n<ul>\n<li>공유 데이터</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> turn<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 변수 진입 순번</span>\n<span class=\"token keyword\">int</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 임계구역 진입 준비 상태, 각 인덱스가 프로세스를 의미</span></code></pre></div>\n<p>피터슨 해결안의 핵심은 <code class=\"language-text\">양보</code>에 있다. 각 프로세스는 임계구역에 다다르게 되면 자신이 아닌 다른 프로세스에게 임계 구역 진입 차례(turn)를 양보한다. 두 프로세스 i 와 j의 실행흐름을 따라가며 피터슨 해결안을 정리해보자.</p>\n<ol>\n<li><code class=\"language-text\">프로세스 i</code> 는 자신이 임계구역에 들어갈 준비가 되면, 자신에 대한 flag 값을 true 로 만든다.</li>\n<li>그리고 동시에 turn 은 자신이 아닌 <code class=\"language-text\">프로세스 j</code>를 가르키게 한다. <code class=\"language-text\">프로세스 j</code>의 준비상태가 true 라고 한다면 프로세스 i는 4번 라인의 while 문의 모든 조건이 true가 되므로 무한루프를 돌게된다.</li>\n<li>이때 <code class=\"language-text\">프로세스 j</code>가 임계구역에 들어갈 준비가 되면 자신의 flag 를 true로 만들고 turn은 <code class=\"language-text\">프로세스 i</code>를 가르키게 한다.</li>\n<li><code class=\"language-text\">프로세스 j</code>가 turn 을 i로 바꾸었기 때문에 <code class=\"language-text\">프로세스 i</code> 는 무한루프에서 빠져나올 수 있다. <code class=\"language-text\">turn == j</code>가 false 가 되었기 때문이다.</li>\n<li>무한루프에서 빠져나온 <code class=\"language-text\">프로세스 i</code>는 임계구역에 진입해서 작업을 수행한다. 이때 <code class=\"language-text\">flag[i] == true, turn == i 가 모두 참</code>이기 때문에 <code class=\"language-text\">프로세스 j</code>는 무한루프를 돌며 대기한다.</li>\n<li><code class=\"language-text\">프로세스 i</code>가 임계구역을 빠져나오면서 flag[i]를 false 로 만든다.</li>\n<li><code class=\"language-text\">프로세스 j</code>는 이제 flag[i] 가 false 가 되었기 때문에 무한루프를 빠져나와 임계구역으로 진입한다.</li>\n<li>위 과정을 반복한다.</li>\n</ol>\n<h2 id=\"solution-analysis\" style=\"position:relative;\"><a href=\"#solution-analysis\" aria-label=\"solution analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution Analysis</h2>\n<p>앞서 정의했던 것에 따르면 임계구역 문제에 대한 해결은 <code class=\"language-text\">Mutual Exclusion</code>, <code class=\"language-text\">Progress</code>, <code class=\"language-text\">Bounded Waiting</code> 의 요구조건을 충족해야 한다.</p>\n<ol>\n<li>Mutual Exclusion(상호 배제) : 동시에 여러 프로세스가 임계구역에 진입하는 것을 허용하면 안된다. 이 조건은 <code class=\"language-text\">while(flag[i] &amp;&amp; turn == i)</code> 에 의해 만족된다. 두 프로세스가 모두 준비상태에 있어 flag[i]와 flag[j]가 모두 true 를 가진다고 해도 <code class=\"language-text\">turn 값은 언제나 i 혹은 j의 값을 하나만 가질 수 있다.</code> 따라서 동시에 두 프로세스가 임계구역에 진입하는 것을 제한한다.</li>\n<li>Progress(진행) : 임계구역이 비어있을 때, 임계구역의 진입여부가 한정된 시간안에 결정되어야 한다. 이 조건은 임계구역을 빠져나오면서 실행되는 <code class=\"language-text\">flag[i] = false</code> 와 <code class=\"language-text\">while(flag[i] &amp;&amp; turn == i)</code> 에 의해 만족된다. 프로세스 i 는 임계구역을 빠져나온 직후에 flag[i]를 false 로 만드는데, 이 코드 덕분에 무한루프를 돌며 대기중이던 프로세스 j가 임계구역으로 진입하는 것이 가능해진다. 즉, 임계구역이 비게되자마자 곧바로 다른 준비된 프로세스의 임계구역 진입을 허락하는 것이다.</li>\n<li>Bound Waiting(한정된 대기시간) :<code class=\"language-text\">flag[i] = false</code> 와 <code class=\"language-text\">while(flag[i] &amp;&amp; turn == i)</code> 는 2번 조건을 만족시킴과 동시에 3번 조건도 만족시킨다. 이 코드를 통해서 두 프로세스는 무한정하게 임계구역 진입을 위해 기다리지 않고, 다른 한 프로세스가 임계구역을 빠져나오게 되면 곧바로 임계구역으로의 진입이 가능해진다.</li>\n</ol>\n<h2 id=\"could-it-be-a-ulimate-solution\" style=\"position:relative;\"><a href=\"#could-it-be-a-ulimate-solution\" aria-label=\"could it be a ulimate solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Could It be a Ulimate Solution?</h2>\n<p>피터슨의 해결책은 임계구역 문제를 해결하는 요구조건을 설명하기에 가장 간단하면서도 적합한 해결책이다. 하지만 현대의 컴퓨팅 시스템에서는 피터슨 해결책이 임계구역 문제를 항상 해결해주지는 않는다.</p>\n<p>그 이유는 시스템의 성능을 향상 시키기 위해서 프로세스나 컴파일러가 서로 종속성이 없는 명령어들의 순서를 바꿔서 실행하기 때문이다. 컴퓨터 구조에서 배웠겠지만, 이렇게 재정렬된 프로그램이 단일한 스레드로 이루어진 응용프로그램에 의해 실행되었다면 결과에 달라지는 부분이 없겠지만, 다중스레딩 환경에서는 데이터의 공유가 일어나기 때문에 결과가 달라지는 문제가 생길 수도 있다.</p>","frontmatter":{"title":"[운영체제] 임계 구역 문제와 피터슨의 해결안(Critical Section Problem and Peterson's Solution)","date":"May 14, 2020"}}},"pageContext":{"slug":"/Operating-Systems/2020-05-14-운영체제-임계구역문제/","previous":{"fields":{"slug":"/Algorithm-Analysis/2020-05-13-알고리즘-MST-크루스칼알고리즘/"},"frontmatter":{"title":"[알고리즘 정리] 크루스칼 알고리즘(Kruskal Algorithm)","category":"Algorithm-Analysis","draft":false}},"next":{"fields":{"slug":"/Algorithm-Analysis/2020-05-15-알고리즘-SSP-벨만포드알고리즘(BellmanFord)/"},"frontmatter":{"title":"[알고리즘 정리] 벨만-포드 알고리즘(Bellman-Ford Algorithm)","category":"Algorithm-Analysis","draft":false}}}}}