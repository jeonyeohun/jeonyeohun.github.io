{"componentChunkName":"component---src-templates-blog-post-js","path":"/Database/2020-04-10-데이터베이스-정규화/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.netlify.app","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"20a72e53-0679-52b8-a76a-58792f2b4f10","excerpt":"Normalization 지난 포스트에서 데이터베이스에서 발생하는 anomaly, 그리고 함수적 종속성을 의마하는 functional dependency 에 대해 정리했다. 오늘은 데이터베이스의 anomaly 를 해결하는 표준인 Normalization 을 정리하자. Normalization 은 데이터베이스의 테이블들이 서로 Anomaly를 만들지 않도록 하기 위해서 정규화된 모양을 제시하는 것을 말한다. 1NF 부터 6NF, 그리고 중간에 BCNF 가 있지만 여기서는 1NF ~ 3NF…","html":"<h2 id=\"normalization\" style=\"position:relative;\"><a href=\"#normalization\" aria-label=\"normalization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Normalization</h2>\n<p>지난 포스트에서 데이터베이스에서 발생하는 anomaly, 그리고 함수적 종속성을 의마하는 functional dependency 에 대해 정리했다. 오늘은 데이터베이스의 anomaly 를 해결하는 표준인 Normalization 을 정리하자.</p>\n<p>Normalization 은 데이터베이스의 테이블들이 서로 Anomaly를 만들지 않도록 하기 위해서 정규화된 모양을 제시하는 것을 말한다. 1NF 부터 6NF, 그리고 중간에 BCNF 가 있지만 여기서는 1NF ~ 3NF 그리고 BCNF에 대해 정리하도록 하자.</p>\n<h2 id=\"1nf-first-normal-form\" style=\"position:relative;\"><a href=\"#1nf-first-normal-form\" aria-label=\"1nf first normal form permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1NF (First Normal Form)</h2>\n<ol>\n<li>Relation 의 모든 attribute 가 atomic value 의 형태를 가져야 한다.</li>\n</ol>\n<p>제 1 정규형의 규칙은 단순하다. 여기서 atomic value는 더 이상 쪼개질 수 없다는 것을 의미한다. 따라서 정말 단순하게 각 attribute가 하나의 값만을 가지고 있어야 한다는 것이다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Student_id</th>\n<th align=\"center\">Student_name</th>\n<th align=\"center\">department</th>\n<th align=\"center\">course_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">여훈</td>\n<td align=\"center\">전전</td>\n<td align=\"center\">1, 2, 3</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">윤이</td>\n<td align=\"center\">상사</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody>\n</table>\n<p>위와 같은 테이블이 있다고 하자. 1NF 를 만족하려면 모든 attribute가 원자값을 가져야하는데, 여훈이의 course_id 정보를 보면 3개의 값이 합성되어 들어가있다. 따라서 1NF를 만족시키기 위해 이 tuple을 쪼개주어야 한다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Student_id</th>\n<th align=\"center\">Student_name</th>\n<th align=\"center\">department</th>\n<th align=\"center\">course_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">여훈</td>\n<td align=\"center\">전전</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">여훈</td>\n<td align=\"center\">전전</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">여훈</td>\n<td align=\"center\">전전</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">윤이</td>\n<td align=\"center\">상사</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody>\n</table>\n<p>중복된 정보가 많이 들어가 있어 별로 좋은 테이블로 보이지는 않지만 어쨋든 1NF에는 만족하게 된다.</p>\n<h2 id=\"2nf-second-normal-form\" style=\"position:relative;\"><a href=\"#2nf-second-normal-form\" aria-label=\"2nf second normal form permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2NF (Second Normal Form)</h2>\n<ol>\n<li>1NF 를 만족해야 한다.</li>\n<li>테이블의 모든 attribute가 Primary Key 에 대해 full functional dependency 를 만족해야 한다. 즉, partial dependency가 존재하면 안된다.</li>\n</ol>\n<p>Normalization은 차수가 올라갈수록 이전 차수의 규칙을 포함하게 된다. 제 2 정규형은 제 1 정규형을 만족하면서 동시에 규칙이 하나 더 추가된다. 모든 attribute가 함수적 종속성을 만족해야한다는 것이다. 이 정규형을 만족시키기 위해서는 테이블 내에 모든 함수적 종속성 관계를 먼저 파악하는게 좋다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Student_id</U></th>\n<th align=\"center\"><U>Course_name</U></th>\n<th align=\"center\">Class_room</th>\n<th align=\"center\">Grade</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n<td align=\"center\">3.0</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n<td align=\"center\">3.5</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">알고리즘</td>\n<td align=\"center\">411</td>\n<td align=\"center\">2.5</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">심리학개론</td>\n<td align=\"center\">102</td>\n<td align=\"center\">4.5</td>\n</tr>\n</tbody>\n</table>\n<p>위와 같은 테이블에서 함수적 종속성을 모두 나열해보자.</p>\n<ol>\n<li>{Student<em>id, Course</em>name} -> Class_room</li>\n<li>{Student<em>id, Course</em>name} -> Grade</li>\n<li>Course<em>name -> Class</em>room</li>\n</ol>\n<p>1, 2번 의 경우는 괜찮은데, 3번의 경우에는 Class<em>room 이 Primary Key 인 {Student</em>id, Course_name} 에 부분적으로 종속되게 되어 2NF 규칙에 위배된다. 2NF를 만족하는 모양으로 만들기 위해서는 이 테이블을 쪼개주어야 한다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Student_id</U></th>\n<th align=\"center\"><U>Course_name</U></th>\n<th align=\"center\">Grade</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">3.0</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">3.5</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">알고리즘</td>\n<td align=\"center\">2.5</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">심리학개론</td>\n<td align=\"center\">4.5</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Course_name</U></th>\n<th align=\"center\">Class_room</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n</tr>\n<tr>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n</tr>\n<tr>\n<td align=\"center\">알고리즘</td>\n<td align=\"center\">411</td>\n</tr>\n<tr>\n<td align=\"center\">심리학개론</td>\n<td align=\"center\">102</td>\n</tr>\n</tbody>\n</table>\n<p>이렇게 두 테이블로 나누어 주면 각각의 테이블이 함수적 종속성을 완전히 만족하는 것을 확인할 수 있다.</p>\n<h2 id=\"3nf-third-normal-form\" style=\"position:relative;\"><a href=\"#3nf-third-normal-form\" aria-label=\"3nf third normal form permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3NF (Third Normal Form)</h2>\n<ol>\n<li>2NF 를 만족해야한다.</li>\n<li>Primary Key가 아닌 attribute가 Primary Key에 transitive functioncal dependency를 가지면 안된다.</li>\n</ol>\n<p><strong>Transitive Functional Dependency</strong> : 우리말로 이행적 함수 종속이라고 한다. 우리말이 아니네.. 수학적 기호로 표시했을 때 다음과 같은 논리로 표현되는 종속관계이다.</p>\n<center>if X -> Y, Y -> Z then X -> Z</center></br>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Student_id</U></th>\n<th align=\"center\">Course_name</th>\n<th align=\"center\">Class_room</th>\n<th align=\"center\">Grade</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n<td align=\"center\">3.0</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n<td align=\"center\">3.5</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">알고리즘</td>\n<td align=\"center\">411</td>\n<td align=\"center\">2.5</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">심리학개론</td>\n<td align=\"center\">102</td>\n<td align=\"center\">4.5</td>\n</tr>\n</tbody>\n</table>\n<p>위 테이블을 보자. Student_id 는 Primary Key로 다른 모든 attribute를 특정할 수 있게 한다.\n이행적 함수 종속을 확인해보자.</p>\n<ol>\n<li>Student<em>id(X) -> Course</em>name(Y)</li>\n<li>Course<em>name(Y) -> Class</em>room(Z)</li>\n<li>Student<em>id(X) -> Class</em>room(Z)</li>\n</ol>\n<p>테이블이 그닥 좋은 예시 테이블은 아닌것 같지만 위 종속관계를 보면, Student<em>id 를 통해 Course</em>name 을 특정할 수 있고, Course<em>name 을 통해 Class</em>room 을 특정 할 수 있기 때문에, Student<em>id 가 Class</em>room 을 특정하게 된다. 문제가 없는 것 같지만, 사실 교실을 결정하는 것은 수업이름이지 학번이 아니다. 따라서 논리적으로 말이 안되는 구조가 생겨버린것이다. 이런 관게를 분리해줄 때는, X, Y 를 따로 한 테이블, Y, Z 를 따로 한 테이블로 만들어주면 된다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Student_id</U></th>\n<th align=\"center\">Course_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">데이터베이스</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">데이터베이스</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">알고리즘</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Course_name</U></th>\n<th align=\"center\">Class_room</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n</tr>\n<tr>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">203</td>\n</tr>\n<tr>\n<td align=\"center\">알고리즘</td>\n<td align=\"center\">411</td>\n</tr>\n<tr>\n<td align=\"center\">심리학개론</td>\n<td align=\"center\">102</td>\n</tr>\n</tbody>\n</table>\n<p>이제 이행적 함수종속이 발생하지 않는 테이블 두 개가 만들어졌다.</p>\n<h2 id=\"bcnf-boyce-codd-normal-form\" style=\"position:relative;\"><a href=\"#bcnf-boyce-codd-normal-form\" aria-label=\"bcnf boyce codd normal form permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BCNF (Boyce Codd Normal Form)</h2>\n<ol>\n<li>3NF를 만족한다</li>\n<li>X->Y 일 때, 모든 X 항상 Candidate Key 이거나 Y 에 속해야한다.</li>\n</ol>\n<p>BCNF 는 제 3 정규형을 조금 더 강화한 형태이다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Student_id</U></th>\n<th align=\"center\"><U>Course_name</U></th>\n<th align=\"center\">professor</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">데이터베이스</td>\n<td align=\"center\">여훈</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">모바일앱개발</td>\n<td align=\"center\">윤이</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">자바 프로그래밍</td>\n<td align=\"center\">여훈</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">알고리즘</td>\n<td align=\"center\">지은</td>\n</tr>\n</tbody>\n</table>\n<p>위 같은 테이블이 있다고 하자. 먼저 각 정규화 모델은 만족하는지 확인해보자.</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> 1NF: 모든 Attrubute 들은 atomic한 값을 가지고 있다.</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled> 2NF: Partial dependency가 존재하지 않는다.</p>\n<ul>\n<li>{Student<em>id, Course</em>name} -> professor</li>\n<li>professor -> Course_name</li>\n</ul>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled> 3NF: Transitive dependency 가 존재하지 않는다.</p>\n<ul>\n<li>{Student<em>id, Course</em>name} -> professor</li>\n<li>professor -> Course_name</li>\n<li>{Student<em>id, Course</em>name} -> Course_name &#x3C;&#x3C; <strong>NO!</strong></li>\n</ul>\n</li>\n</ul>\n<p>여기까지만 보면 위 테이블은 정규화를 모두 만족하는 것 처럼 보인다. 하지만 여전히 Anomaly 가 존재한다.</p>\n<ol>\n<li>만약 새로운 강사에 의해 새로운 수업이 열렸을 때, 위 테이블에서 매칭시킬 Student_id가 없기 때문에 insertion anomaly 가 발생한다.</li>\n<li>Student_id = 2 를 지우게 되면, 모바일 앱 개발이라는 수업과 윤이라는 교수이름이 사라지게 된다. 따라서 deletion animaly 가 발생한다.</li>\n<li>데이터베이스 수업의 교수가 바뀌게 될 경우에는 위 테이블에서는 한명이지만, 모든 수강생에 대해서 정보를 바꿔줘야하는 update anomaly 또한 존재한다.</li>\n</ol>\n<p>따라서, BCNF 를 통해 정규화 작업을 거쳐야 할 필요가 있다. 위 테이블을 잘 살펴보면, Primary key 가 아닌 professor 가 primary key의 부분 attribute에 대해서 결정자가 된다. BCNF는 이런 구조를 허용하지 않는다. 따라서 이 테이블을 나누어주어야 하는데 다음과 같이 규칙을 따라서 나누자.</p>\n<ol>\n<li>\n<p>Primary Key 가 아닌 결정자의 함수 종속관계를 찾는다. 위 테이블에서는 아래 관계가 그렇다.</p>\n<ul>\n<li>professor(X) -> Course_name(Y)</li>\n</ul>\n</li>\n<li>\n<p>두개의 테이블로 이제 나누는데,</p>\n<ol>\n<li>XY 로 구성된 테이블,.</li>\n<li>X와 사용하지 않은 나머지 attribute들로 구성된 테이블로 나누어준다.</li>\n</ol>\n</li>\n</ol>\n<p>위 규칙에 따라 테이블을 나누면,</p>\n<ul>\n<li>professor -> Coursename</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"right\"><U>professor </U></th>\n<th align=\"center\">Course_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"right\">여훈</td>\n<td align=\"center\">데이터베이스</td>\n</tr>\n<tr>\n<td align=\"right\">윤이</td>\n<td align=\"center\">모바일앱개발</td>\n</tr>\n<tr>\n<td align=\"right\">여훈</td>\n<td align=\"center\">자바 프로그래밍</td>\n</tr>\n<tr>\n<td align=\"right\">지은</td>\n<td align=\"center\">알고리즘</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Student_id ->professor</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><U>Student_id</U></th>\n<th align=\"center\">professor</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">여훈</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">윤이</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">여훈</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">지은</td>\n</tr>\n</tbody>\n</table>\n<p>이렇게 나누게 되면 BCNF까지 모두 만족하는 두 개의 테이블로 나누어지게 된다.</p>\n<p>유투브 강의나 다른 블로거들의 예제를 많이 찾아봤는데 Student_id 와 professor 로 이루어진 테이블이 조금 이상하게 느껴지긴 한다. take 관계라고 말할 수 있는걸까..?</p>","frontmatter":{"title":"[데이터베이스] 정규화(Normalization) - 1NF,2NF, 3NF, BCNF","date":"April 10, 2020"}}},"pageContext":{"slug":"/Database/2020-04-10-데이터베이스-정규화/","previous":{"fields":{"slug":"/Algorithm-Analysis/2020-04-09-알고리즘-그리디-알고리즘/"},"frontmatter":{"title":"[알고리즘 정리] 그리디 알고리즘(Greedy Alogorithm)","category":"Algorithm-Analysis","draft":false}},"next":{"fields":{"slug":"/Database/2020-04-11-데이터베이스-키/"},"frontmatter":{"title":"[데이터베이스] 키(Key)","category":"Database","draft":false}}}}}