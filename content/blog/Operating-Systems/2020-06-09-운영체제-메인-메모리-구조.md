---
title: '[운영체제] 메인 메모리의 구조'
date: 2020-06-09 19:05:26
category: Operating-Systems
thumbnail: { thumbnailSrc }
draft: false
---

참고도서: _Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne_

## 메인 메모리

컴퓨터 시스템 안에서 CPU가 직접적으로 접근할 수 있는 저장장치는 각 코어 안에 내장된 캐시와 메인메모리 뿐이다. 메인메모리 없는 컴퓨터는 시체나 다름없는데(사실 다른 주요장치들도 없으면 안되지만), 이 메인메모리가 어떻게 구성되고 관리되는지 공부해보자

## 기준 레지스터와 상한 레지스터

운영체제와 프로세스는 모두 메모리에 적재되어서 실행되어진다. 따라서 메모리 내에서 영역을 정확하게 구분하는 것이 필수적으로 요구된다. 운영체제는 그렇다 치고, 만약 어떤 프로세스가 메모리 여기저기에 데이터를 쓰고 다닌다면... 상상만해도 끔찍쓰..

이렇게 각 프로세스마다 명확한 공간을 분리하기 위해서 `기준 레지스터(base register)` 와 `상한 레지스터(limit register)` 를 사용하게된다. 기준 레지스터는 어떤 프로세스가 시작되는 가장 첫 시작주소를 가지고, 상한 레지스터는 해당 프로세스가 최대로 사용할 공간을 가진다. 따라서 이 프로세스는 기준 주소부터 `기준+상한` 주소까지의 메모리 공간을 사용하고 보호받게 되는 것이다. 만약 어떤 프로세스의 연산이 다른 프로세스의 영역을 침범하게 된다면, 운영체제는 이 접근을 허용하지 않고 트랩을 통해서 동작을 정지시킨다.

## 논리 공간과 물리 주소공간

CPU가 연산을 진행하며 생성하는 주소는 메모리에서 사용하는 주소와 다르다. 우리는 CPU에서 생성되는 주소를 `논리 주소(Logical address)` 라고 하고, 메모리에서 사용하는 주소를 `물리 주소(Physical address)` 라고 한다. 이것은 CPU에서 생성된 주소로 메모리에 접근하면 원하는 결과를 얻을 수 없다는 것을 의미한다. 따라서 CPU와 메모리 사이에서 논리 주소를 물리 주소로 변환시켜주는 작업을 하는 장치가 필요하다.

이 장치를 우리는 `메모리 관리 장치(MMU)` 라고 부른다. MMU는 다양한 방법을 통해서 논리 주소를 물리 주소로 변환하는데, 가장 간단한 방법이 `재배치 레지스터(relocation register)`를 사용하는 것이다. 재배치 레지스터의 역할은 앞서 설명했던 기준 레지스터의 역할과 비슷하다. 이 레지스터는 각 프로세스의 어떤 특정한 값을 가지고 CPU에서 논리 주소가 들어올 때마다 이 값을 논리 주소에 더해서 물리 주소를 만들어낸다. 예를 들어, CPU에서 생성한 주소가 30 이고 재배치 레지스터의 값이 300 이라면, CPU는 메모리 주소 330번지에 있는 데이터에 접근하게 되는 것이다.

이렇게 논리 주소를 물리주소로 변환해서 CPU가 바로 메모리에 접근할 수 없게 하는 것의 이점은 메모리 내의 프로세스의 위치가 달라져도 CPU는 항상 같은 논리 주소로 해당 프로세스에 접근할 수 있다는 것이다.

## 메모리 할당

프로그램이 프로세스가 되어 메모리에 적재될 때, 가장 간단한 방법은 `가변 파티션(Dynamic partitioning)` 이다. 단순하게 새로 메모리에 올라온 프로세스를 사용가능한 공간에 적재시키는 것이다. 이렇게 메모리를 관리하게 되면, 사용가능한 메모리 영역이 구분되게 되는데 이런 공간을 `hole`이라고 한다. 유의할 점은 hole이 단순하게 모든 사용가능한 공간의 합을 의미하지 않는다는 것이다. 만약 연속된 메모리 공간에 프로세스 1, 프로세스 2, 프로세스 3 이 적재되어 있을 때, 프로세스 2의 작업이 끝나고 메모리에세 제거 되면, 메모리에는 프로세스 1의 공간과 프로세스 3의 공간 사이에 있는 hole, 그리고 프로세스 3 이후의 있는 빈 공간들로 총 두 개의 hole이 존재하게 된다.

여기서 한가지 문제점이 발생한다. 프로세스가 계속해서 메모리에 적재되고 해제되다 보면 수많은 hole이 생겨날텐데, 새로 들어온 프로세스는 이들 중 어디에 적재시켜야 할까? 이 문제를 해결하기 위해 세 가지 방법이 제안된다.

1. `최초 적합(First-fit)`: 메모리의 시작점 혹은 끝 지점부터 순서대로 탐색하면서, 새 프로세스를 적재할 수 있는 크기를 가진 hole이 등장하면 곧바로 프로세스를 적재시킨다.
2. `최적 적합(Best-fit)`: 메모리에 있는 모든 hole을 다 확인해서 사용가능한 hole 중 새 프로세스와 크기가 가장 가까운 hole에 프로세스를 적재시킨다. 단점은 모든 hole들을 다 탐색해야하기 때문에 오버헤드가 발생하게 된다.
3. `최악 적합(Worst-fit)`: 메모리에 있는 모든 hole을 다 확인해서 사용가능한 hole 중 크기가 가장 큰 hole에 프로세스를 적재한다. 이떄 프로세스를 적재하고 남은 크기는 다시 또 새로운 hole 이 된다. 이 방법 역시 메모리 내의 모든 hole을 다 검사해야하는 오버헤드가 발생한다.
