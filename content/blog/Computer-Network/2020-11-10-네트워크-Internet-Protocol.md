---
title: '[네트워크] IP : Internet Protocol - IPv4'
date: 2020-11-10 19:05:66
category: Computer-Network
thumbnail: { thumbnailSrc }
draft: false
---

_**참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음**_

## 네트워크 계층

네트워크 계층은 호스트와 호스트간의 패킷을 전달하는 논리적 역할을 하는 계층이다. 네트워크 계층의 기능은 크게 두 가지로 나눌 수 있다.

1. Forwarding(Data Plane) : 데이터를 다루는 `Data plane` 영역에서는 패킷을 어떻게 전달할지를 결정하게 된다. 이 영역은 다른 라우터들과는 전혀 관계없이 현재 패킷을 가지고 있는 라우터만 고려하면 된다.
2. Routing(Control Plane) : 제어를 담당하는 `Control plane` 영역에서는 패킷을 어떤 경로로 전달하지 그 최적의 경로를 결정하는 역할을 한다. 최적의 경로를 찾아야하기 때문에 이 영역은 다른 라우터들에 대한 정보를 필요로 하고 특정한 라우팅 알고리즘을 통해서 최적의 경로를 설정한다. 이 라우팅 알고리즘을 통해서 라우터는 `forwarding table` 을 가지게 되는데, 이 테이블은 전달받은 패킷 헤더의 필드값을 조사해서 얻은 값을 포워딩 테이블의 인덱스로 사용해 해당 패킷이 전달되어야 할 다음 경로를 라우터에게 알려준다.

## Forwaring Table 의 생성

forwarding table 은 두 가지 다른 방법으로 구성될 수 있다.

1. Per-router Control Plane: 이 방법은 네트워크 내에 있는 각각의 라우터들이 서로 라우팅 메세지를 교환하며 포워딩 테이블의 값을 계산하는 가장 전통적인 방식이다. 각 라우터들이 라우팅 알고리즘을 실행하고 다른 라우터들과 정보를 주고받아야하기 때문에 포워딩과 라우팅 기능을 모두 제공해야한다.
2. Logically Centralized Control Plane: 이 방법은 물리적으로 라우터들과 분리된 원격 컨트롤러 컴퓨터가 라우팅 알고리즘을 수행해서 포워딩 테이블을 생성하고, 각 라우터들은 만들어진 테이블을 기반으로 포워딩 기능만을 수행한다.

## 네트워크 계층의 기능

네트워크 계층은 다음과 같은 기능들을 제공한다.

1. Addressing: 패킷의 목적지를 설정.
2. Routing: 패킷의 전송경로를 설정.
3. Fragmentation: 패킷을 더 작은 조각으로 나누고 나뉘어진 채로 전달된 패킷을 다시 합친다.
4. Packetization: 윗 계층에서 전달된 세그먼트를 데이터그램으로 캡슐화한다.

1, 2, 4 번은 모두 앞선 공부들에서 정리했으니, `Fragmentation` 을 먼저 정리해보자.

### Fragmentation

Layer 2 인 `링크 계층`에서는 각 네트워크의 링크들이 한번에 전달할 수 있는 최대 데이터 양을 규정하고, 이를 `MTU(Maximum Transmission Unit)` 이라고 한다. 문제는 각 라우터들이 각기 다른 MTU를 가지고 있기 때문에 가장 처음에는 전달할때는 패킷의 사이즈가 괜찮았더라도, 중간 링크에서 해당 패킷을 전달할 수 없는 상황이 생길 수도 있다.

Fragmentation은 이와 같은 문제를 해결하기 위해서 데이터그램을 더 작은 단위로 나누고 링크계층으로 보내 별도의 패킷으로 나누어서 보내는 방법이다. 이때 패킷의 경로에 있는 모든 라우터를 확인해서 가장 MTU가 작은 값을 `Path MTU` 라고 하고, 이 방법은 주로 `IPv6` 에서 사용된다. `IPv4` 에서는 패킷의 fragmentation 과 reassembly 를 위해서 몇가지 헤더필드를 사용하는데, 다음헤더들이 그 기능을 수행한다:

1. Identification: 식별자 역할을하는 이 헤더필드는 새로운 데이터그램이 들어올 때마다 1씩 증가시켜서 각 데이터그램이 `고유한 식별자`를 갖게끔 한다. 이 식별자는 fragmentation이 된다고 하더라도 나누어진 데이터그램들이 같은 식별자를 가지기 때문에 여러 패킷조각들이 한 데이터그램에서 왔다는 것을 알 수 있게 해준다.
2. Flags: 이 헤더필드에 `DF bit` 가 설정되면 이 헤더를 가진 데이터그램은 fragmeation이 되면 안된다는 것을 의미한다. 만약 DF bit를 가진 데이터그램이 라우터에 도착하고 이 데이터그램을 fragmentation 해야하는 상황이 발생하면, 라우터는 이 데이터그램을 버리고 `ICMP`로 에러를 알리는 패킷을 보낸다. `MF bit` 는 fragment 된 데이터그램들 중 마지막을 제외한 모든 패킷이 가지게 된다. 이렇게 마지막을 제외한 모든 패킷에 MF 비트를 주어서 마지막까지 나누어진 패킷이 모두 도착했는지를 알 수 있다.
3. Fragment Offset: 데이터가 나누어진 조각의 위치를 명시하기 위해서 사용한다. offset에 8을 곱하면 실제 데이터의 위치 값을 얻을 수 있다.

### Reassembly

- 여러조각으로 나뉘어져 도착한 fragment 들을 다시 하나로 합쳐 데이터그램으로 만들려면, 어느단계에서 합치는 작업을 해야할지 정하는 것이 중요하다.
- IP에서는 최종 목적지에 도착한 이후에 다시 합치도록 한다.
- 이떄 발생하는 단점은 하나의 fragment만 유실되더라도 모든 조각들을 다 버려야 하고, 무한정 fragment 를 기다리지 않게 하기 위해 사용하는 reassembly timer 가 종료 되었을 때도 모든 조각들을 다 버려야 한다는 점이다.

## Internet Protocol : IPv4

- IPv4는 Best-effort service 를 지원한다. 따라서 최선을 다하지만, 데이터 전달, 오류, 전달 순서 등을 항상 보장하지는 않는다.
- Routing 은 별도의 프로토콜을 통해서 수행하고 `Forwarding` 기능만 수행한다.
- IPv4 의 헤더는 다음과 같이 구성된다.

1. `VER(4 bits)` : 현재 IP 프로토콜의 버전. IPv4 는 4 를 기입힌다.
2. `HLEN(4 bits)` : 헤더의 길이를 기입한다. 일반적으로 옵션을 포함하지 않으면 `20 바이트` 가 헤더길이가 된다.
3. `Service(8 bits)` : 여러 다른 유형의 데이터그램을 식별하기 위해서 사용하지만, 잘 사용되지 않고 ECN 같은 비트를 넣어서 Congestion Control을 하는데에 사용하기도 한다.
4. `Total Length(16 bits)` : 바이트로 계산한 헤더와 데이터의 전체 길이를 기입한다.
5. `Identification(16 bits)` : fragmentation 처리에 사용될 데이터그램의 식별자를 입력한다. 새로운 데이터그램이 들어오면 1씩 증가시킨 값을 할당해서 데이터그램들이 고유한 값을 가지도록 한다.
6. `Flags(3 bits)` : 조각난 데이터그램을 표현하고 조각들의 마지막 패킷을 표시하기 위해서 사용한다.
7. `Fragmentation offset(13 bits)` : 데이터들의 실제 위치를 기록해서 다시 합칠 때 순서를 유지할 수 있도록 한다.
8. `Time To Live(8 bits)` : 라우터 하나를 거칠때마다 1씩 감소하고, 0이 되면 해당 패킷은 버려진다.
9. P`rotocol(8 bits)` : 상위 계층에서 이 데이터그램을 받아 사용할 프로토콜을 명시한다. 즉, 트랜스포트 계층에서 사용할 프로토콜이 UDP가 될지, TCP가 될지 기록하게 된다.
10. `Header Checksum(16 bits)` : 헤더와 데이터를 사용해서 체크섬을 만들어 오류확인에 도움을 준다.
11. `Source IP address(32 bits)` : 데이터그램을 전송한 호스트의 ip 주소를 기입한다.
12. `Destination IP address(32 bits)` : 데이터그램을 수신할 목적지 호스트의 ip주소를 기입한다.

### IPv4 Addressing

- ip 주소는 각 호스트에 연결된 `Network Interface Card` 마다 하나씩 부여된다. 그리고 이 주소는 전세계에 하나 뿐인 고유한 주소가 된다.
- 각 호스트나 라우터가 물리적 링크와 연결되는 지점을 `Interface` 라고 한다.
- IPv4의 주소체계는 계층적 구조로 이루어져 있고, 32 비트 주소를 `network id` 와 `host id` 로 나누어서 사용한다. 따라서 한 네트워크 그룹에 속한 모든 호스트는 같은 network number 를 공유하게 된다.
- `InterNIC` 는 `AS(Autonomous System)` 라고 불리는 네트워크 관리 주체에 `network id`를 부여하고 각 AS는 네트워크 내의 호스트들에게 `host id` 를 부여한다.
- IPv4는 `Dotted Deicmal` 체계로 주소를 표현하는데, 이진수로 표현된 주소를 8비트씩 잘라서 10진수로 변환한 뒤에 사이사이에 점을 찍어 표현하는 형태이다. 예를 들어 `11000000 00000101 00110000 00000011` 로 표현된 주소는 `192.5.48.3` 으로 변환된다.

### Classful IP Addressing

IPv4 의 초창기에는 주소를 여러 클래스로 나누어서 net id와 host id 의 비율을 결정하는 방식으로 주소를 할당했다. 이 비율은 host id의 비트로 표현할 수 있는 최대 갯수를 결정하기 때문에, 네트워크에 참여하는 호스트들의 개수가 중요하다.

- 각 클래스들을 식별하기 위해서 주소의 앞 몇 비트들을 클래스 식별자로 사용하는데 각 식별자와 범위는 다음과 같다.

| 클래스 |  식별자   | NetID 사용 비트 | HostID 사용 비트 | 시작주소  |     끝주소      |
| :----: | :-------: | :-------------: | :--------------: | :-------: | :-------------: |
|   A    | 0XXXXXXXX |        7        |        24        |  0.0.0.0  | 127.255.255.255 |
|   B    | 10XXXXXXX |       14        |        16        | 128.0.0.0 | 191.255.255.255 |
|   C    | 110XXXXXX |       21        |        8         | 192.0.0.0 | 223.255.255.255 |
|   D    | 1110XXXXX |        -        |        -         | 224.0.0.0 | 239.255.255.255 |
|   E    | 1111XXXXX |        -        |        -         | 240.0.0.0 | 255.255.255.255 |

- Class A 부터 C 까지는 `Unicast address` 이고 D는 `Multicast address` 인데, 각 주소에 맵핑되는 호스트들이 1대1 관계인지 1대다 관계인지에 따라 나뉜다.

### Subnetting

- Subnet 이라는 기술은 여러개의 인터페이스가 서로 연결되는 네트워크를 의미한다. 서브넷에 있는 ip 주소들은 서로 공통된 ip 주소의 일부를 공유하게 되는데 이때 사용하는 주소 체계를 `CIDR(Classless InterDomain Routing)`이라고 한다. CIDR 은 공통된 ip 주소와 함께 슬래쉬와 비트수를 사용해서 주소를 나타낸다. 예를 들어 233.1.1.2, 233.1.1.4, 233.1.1.5 로 구성된 서브넷이 있다고 하면, `233.1.1/24` 와 같이 나타내고 `/24` 부분을 `Subnet Mask` 라고 한다.

- CIDR을 사용하면 해당 주소를 읽을 수 있는 라우터에서 일단 CIDR의 공통된 주소를 받는 요청을 모두 받고 서브넷 안의 호스트에게 나누어주면 되기 때문에 훨씬 더 효율적으로 주소를 처리할 수 있게된다. 이렇게 모든 서브넷 호스트의 ip주소를 포함하는 ip주소를 한 라우터에서 처리할 수 있게 하는 방법을 `route aggregation` 이라고 한다.

- 그렇다면 만약 다음과 같은 상황에서는 어떨까? `11001000 00010111 00010000 00000000` 이라는 주소가 있고, `11001000 00010111 00010010 00000000` 두 개의 주소가 각각 다른 인터페이스와 매핑되어 있을 때 두 주소를 모두 포함하는 주소가 새로 들어온다면, 어떤 인터페이스 경로로 가야할까? 왜냐하면 두 번째 주소는 0001 까지는 첫 주소의 인터페이스와 매치되고, 0001001 까지는 두번째 주소의 인ㅌ터페이스와 매칭되기 때문에 자칫하면 항상 첫번째 인터페이스로 이동하게되기 때문이다. 따라서 CIDR 정책을 사용할 때는 항상 주소를 가장 길게 매칭되는 지점까지 검사해야할 필요가 있다.
