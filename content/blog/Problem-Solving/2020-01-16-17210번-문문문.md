---
title: '[백준 알고리즘] 17210번: 문문문'
date: 2020-05-05 00:00:00
category: Problem-Solving
thumbnail: { thumbnailSrc }
draft: false
comments: true
---

### [17210번: 문문문](https://www.acmicpc.net/problem/17210)

```
문제
유신이는 여러개의 문을 통과해야 밖으로 나갈 수 있는 방에 갇혔다. 유신이를 가둔 재현이는 유신이가 탈출할 수 없도록 하기 위해 특이한 규칙을 만들어 문을 순서대로 규칙에 맞는 방법으로 열어야하도록 시스템을 구성하였다.

규칙 1 : 문을 여는 방법은 두가지가 있다. 밀어서 여는 법과 당겨서 여는 법이 있다.

규칙 2 :연속 2번 같은 방법으로 문을 열 수 없다.

규칙 3 : 2의 배수(2,4,6,...)번째 문들은 반드시 같은 방법으로 문을 열어야 한다. 예를 들어 2번째 통과하는 문을 밀어서 열었다면, 4번째 통과하는 문 또한 밀어서 열어야 한다.

규칙 4 : 3의 배수(3,6,9,...)번째 문들은 반드시 같은 방법으로 문을 열어야 한다. 예를 들어 3번째 통과하는 문을 밀어서 열었다면, 6번째 통과하는 문 또한 밀어서 열어야한다.
유신이는 위의 규칙 4가지를 모두 알고 있음에도 불구하고 탈출하지 못하고 있다. 유신이가 방을 탈출할 수 있도록 도와주는 프로그램을 만들어보자.

입력
첫째 줄에 총 문의 개수 N(2 ≤ N ≤ 2,500,000,000)이 주어진다.

둘째 줄에는 유신이가 첫 번째 문을 통과할 때 문을 연 방법이 주어진다. 밀어서 여는 법은 숫자 0, 당겨서 여는 법은 숫자 1로 표기된다.

출력
두 번째 문부터 문을 여는 방법을 한줄에 하나씩 출력한다. 만약 탈출이 불가능하다면 "Love is open door"를 출력한다.
```

### 접근 방법:

규칙을 보니 6이상이 되면 해결이 불가능하다. 왜냐하면 규칙 3과 4가 2와 3의 최소공배수인 6을 만들게 되는데 규칙상 연속해서 같은 방법으로 문을 열 수 없기 때문에 어떤 방법으로 시작하든 6에서는 연달아 같은 방법을 사용해야하기 때문이다. 따라서 6 이상일 때는 탈출불가 메세지를 무조건 출력하도록 하고 6이하는 정해진 규칙에 따라 재귀적으로 프린팅하는 함수를 만들어 사용했다.

### 통과 코드:

```cpp

#include <iostream>

using namespace std;


void print_door(int cnt, int N, bool isTwo){
    if (cnt == N) return;
    cout << isTwo << endl;
    print_door(cnt+1, N, !isTwo);
}

int main (){
    int N; cin >> N;
    bool init; cin >> init;

    if (N > 6) {
        cout << "Love is open door";
        return 0;
    }

    print_door(1, N, !init);

    return 0;
}
```
