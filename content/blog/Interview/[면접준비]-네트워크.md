---
title: '[면접준비] 네트워크'
date: 2021-05-24 15:05:77
category: Interview
thumbnail: { thumbnailSrc }
draft: false
---

> 개발자 면접질문과 답변들. 더 많은 내용은 깃허브 저장소에서 확인할 수 있습니다 (https://github.com/jeonyeohun/GetReadyForInterview)

# Application Layer

## HTTP

### HTTP는 statless 하다는 것이 어떤 의미인지 설명해보세요.

- HTTP 는 stateles protocol로 서버가 클라이언트의 상태정보를 저장하지 않는 것을 의미합니다.

### HTTP/1.1 에서 업데이트된 주요 기능들에 대해서 설명해보세요.

- HTTP/1.1 에서는 `Keep Alive` 가 기본설정이 되고 `파이프라이닝`이 추가되었습니다. Keep Alive 는 TCP 연결을 특정 시간동안 유지시켜 새로운 요청이 시작될 때 새로운 연결을 설정할 필요없이 사용하던 TCP 연결을 사용하도록 하는 기능입니다. 파이프라이닝은 클라이언트가 요청을 보내고 응답을 받기 전에 다음 요청을 전송할 수 있도록 하는 기능입니다.

### HTTP/1.1 에서 파이프라이닝을 사용할 때 발생하는 문제는 없을까요?

- 파이프라이닝을 사용하면 `Head of Line Blocking` 문제가 발생합니다. 서버는 클라이언트로부터 연속된 요청을 파이프라이닝을 통해 받았을 때, 순차적으로 처리하기 때문에 첫번째 요청에 대한 처리가 끝나야 다음 요청을 처리할 수 있습니다. 이는 TCP는 응답 순서를 보장해야하기 때문에 그렇습니다. 따라서 만약 첫 요청의 처리시간이 길어지면 쌓여있는 요청들은 첫요청이 끝날때까지 기다려야하는 현상이 발생합니다.

### HTTP/2.0 에서 업데이트된 주요 기능들을 설명해보세요.

- HTTP/2.0 은 응답/요청 메세지를 Plain Text 로 송수신하지 않고 바이너리로 인코딩된 Frame 을 사용합니다. 또한 클라이언트가 요청하지 않았지만 필요로 할 리소스를 송신하는 `Server Push` 도 추가되었습니다. 마지막으로 HTTP/1.1 에서 파이프라이닝의 문제점으로 지적되었던 Head of Line Blocking 문제를 frame 과 stream을 사용하여 Multiplexing 을 지원하는 것으로 해결했습니다.

### HTTP 메서드들과 의미를 설명해보세요.

- HTTP 메세지는 GET, POST, HEAD, PUT, OPTIONS, PATCH, CONNECT, DELETE 가 있습니다.
- `GET` 방식은 서버로부터 리소스를 읽어오기 위해 사용합니다.
- `POST` 방식은 서버에 데이터를 추가하기 위해 사용합니다.
- `HEAD` 방식은 서버에 리소스를 요청하고 응답 body를 제외하고 응답코드와 헤더정보만 응답으로 받기 위해 사용합니다.
- `PUT` 방식은 서버 리소스를 업데이트 하기 위해 사용합니다.
- `OPTIONS` 방식은 클라이언트가 서버가 지원하는 메서드를 확인하기 위해 사용합니다.
- `PATCH` 방식은 서버 리소스의 일부를 업데이트 하기 위해 사용합니다.
- `CONNECT` 방식은 클라이언트가 HTTP 프록시 서버를 통해 서버와 연결을 요청하기 위해 사용합니다.
- `DELETE` 방식은 서버의 리소스를 삭제하기 위해 사용합니다.

### 프록시 서버에 대해서 설명해보세요

- 프록시 서버는 클라이언트와 서버 사이에 징검다리 역할을 합니다. 프록시 서버는 클라이언트가 프록시 서버에 보냈던 요청을 캐싱해두었다가 캐싱된 리소스에 대한 요청을 들어오면 실제 서버로 요청을 보내지 않고 자신이 가진 리소스를 응답해줍니다. 또한 클라이언트와 서버가 직접 통신하지 않고 경유하기 때문에 보안에도 이점이 있습니다.

### 그럼 프록시 서버는 캐시 정보가 최신데이터인지 어떻게 확인할까요?

- 프록시 서버는 실제 서버에 조건부 GET을 사용해서 마지막으로 수정된 시간을 확인합니다. 프록시 서버는 본 서버에 `If-Modified-Since` 헤더에 자신이 가진 리소스의 수정시간을 포함시켜 요청을 보냅니다. 본 서버는 이 헤더에 있는 시간과 자신이 가진 리소스의 시간을 확인하여 시간이 같다면 응답 상태 메세지만 송신하고, 다르다면 최신 리소스를 담아 보냅니다. 프록시 서버는 이 응답을 확인하고 자신의 리소스를 클라이언트로 송신하거나, 새로 받은 리소스를 업데이트 한 뒤에 클라이언트로 송신합니다.

### HTTP 상태코드를 앞번호 기준으로 분류해서 설명해보세요.

- 100번대 코드는 `조건부 응답` 코드로 서버가 요청을 처리했고 추가적인 작업을 수행한다는 것을 클라이언트에게 알립니다.
- 200번대 코드는 `성공` 코드로 클라이언트의 요청을 성공적으로 처리했다는 것을 알립니다.
- 300번대 코드는 `리다이렉트` 코드로 클라이언트가 응답을 받고 추가적인 동작을 수행해야한다는 것을 알립니다.
- 400번대 코드는 `요청오류` 코드로 클라이언트가 서버에 보낸 요청이 잘못되었음을 알립니다.
- 500번대 코드는 `서버오류` 코드로 서버 측 문제로 인해 요청을 처리하지 못했음을 알립니다.

## DNS

### 브라우저에 웹 URL을 입력했을 때 DNS의 동작과정을 설명해보세요.

1. 먼저 입력된 도메인네임이 로컬의 `호스트 파일`과 `DNS 캐시`에 등록되어 있는지 확인합니다. 있다면 반환된 ip 주소를 사용하여 접속합니다.
2. 없다면 `로컬 네임서버`에 도메인 네임을 포함한 쿼리를 전송합니다.
3. 로컬 네임서버는 `루트 네임서버`에 도메인 네임을 포함하는 쿼리를 전송하여 해당 도메인에 대한 TLD 서버의 정보를 반환합니다. 예를 들어 요청된 도메인네임이 www.example.com 이라면, .com 도메인 네임을 관리하는 서버의 정보를 반환합니다.
4. 정보를 받은 로컬 네임서버는 `TLD 서버`에 도메인 네임을 포함한 쿼리를 전송합니다. TLD 서버는 해당 도메인네임에 대한 책임 DNS 서버의 ip주소를 반환합니다.
5. 로컬 네임서버는 전달받은 `책임 DNS 서버`의 ip 주소로 도메인 네임을 포함한 쿼리를 다시 전송합니다.
6. 책임 DNS 서버는 해당 도메인네임에 대한 ip 주소를 로컬 네임서버에게 반환합니다.
7. 로컬 네임서버는 이제 도메인네임에 대한 ip 주소를 알아내었습니다. 따라서 클라이언트에게 해당 ip 주소를 반환합니다.
8. 클라이언트는 전달받은 도메인네임에 대한 ip 주소로 필요한 요청을 보냅니다.

### 이렇게 하면 로컬 네임서버가 매번 각 서버에 쿼리를 보내야할 것 같은데 맞아요? 다른 방법은 없을까요?

- 네 맞습니다. 다른 방법으로는 재귀적으로 쿼리를 요청하는 방법이 있습니다. `재귀적 쿼리요청`은 로컬 네임서버가 아니라 루트, TLD, 책임 DNS 서버가 자신의 하위 계층에 요청을 보내 상위 계층으로 응답을 전달하는 방식으로 동작합니다. 따라서 로컬 DNS 서버는 한번의 쿼리만 보내게되고 이 쿼리가 각 계층의 DNS 서버에 재귀적으로 전달되고 반환됩니다.

## DHCP

### DHCP는 어떤 목적으로 사용되는지 설명해보세요.

- DHCP 는 네트워크 어플리케이션에 동적으로 IP주소를 할당하는 역할을 합니다. DHCP 서버는 각 단말기에서 요청을 받았을 때 임시적으로 사용할 IP주소를 할당해주고 사용이 끝나면 해당 ip주소를 다시 돌려받습니다.

### 단말기가 IP주소를 할당받는 과정을 설명해보세요.

- 단말기는 네 단계에 걸쳐서 ip주소를 할당받습니다.
- 먼저 단말기가 `DHCP Discover` 메세지를 브로드캐스트로 전송합니다.
- 요청을 인지한 DHCP 서버는 단말기로 `DHCP Offer` 메세지를 보냅니다. 이 메세지 안에는 요청을 보낸 단말기의 정보와 할당할 IP 주소, 사용 가능한 시간 등이 포함됩니다.
- 단말기는 DHCP로부터 네트워크 정보를 받습니다. 그리고 `DHCP Request` 메세지를 보내서 해당 IP 주소에 대한 획득을 요청합니다.
- DHCP 서버는 요청을 받고 해당 단말기가 네트워크 정보를 사용하도록 확정합니다. 이를 위해 네트워크 정보다 담겨있는 `DHCP-ACK` 메세지를 전송합니다.

# Transport Layer

## 통신계층에 대해서 설명해보세요.

- 통신계층은 호스트 간의 논리적 통신을 제공하는 네 번째 계층입니다.

## TCP

### TCP 연결의 특징에 대해서 설명해보세요.

- TCP 는 연결지향형 프로토콜로 신뢰성 있는 통신을 보장합니다. 따라서 매 통신마다 데이터를 송수신하기 전에 클라이언트와 서버가 연결을 설정해주어야 합니다. 또한 혼잡제어와 흐름제어를 제공한다는 특징도 있습니다.

### 3-Way Handshaking 을 설명해보세요.

- 3 way handshaking 은 TCP 프로토콜로 연결을 설정하는 과정을 의미합니다. 총 세 단계에 걸쳐 연결을 설정하기 때문에 3 way handshaking 이라고 합니다.
- 먼저 연결설정을 위해 클라이언트가 서버에 `TCP SYN` 요청을 보냅니다.
- 요청을 받은 서버는 `TCP SYN ACK` 로 응답하니다.
- 응답을 받은 클라이언트는 `TCP ACK` 을 다시 요청하고 TCP 연결이 설정됩니다.

### 이때 클라이언트와 서버의 상태는 어떤가요?

- 초기에 클라이언트와 서버는 모두 `CLOSED` 상태에 있습니다.
- 서버는 요청을 받을 준비가 되면 `LISTEN` 상태가 되어 클라이언트의 요청을 기다립니다.
- 클라이언트는 서버에 요청을 보낸 뒤 TCP SYN ACK 을 기다리며 `SYN-SENT` 상태가 됩니다.
- 서버가 요청을 받은 뒤 TCP SYN ACK 을 보내면 `SYN-RECEIVED` 상태가 되어 클라이언트의 SYN ACK 을 기다립니다.
- TCP SYN ACK 을 받은 클라이언트는 서버와의 연결이 완성되었기 때문에 `ESTABLISHED` 상태로 전환되고 서버로 TCP ACK 을 전송합니다.
- TCP ACK 을 서버가 받게되면 두 클라이언트와 서버의 연결이 완성되었으므로 서버의 상태도 `ESTABLISHED` 상태가 됩니다.

### 4-Way Handshaking 을 설명해보세요.

- 4 way handshaking 은 TCP 프로토콜로 설정된 연결을 종료하기 위해 사용됩니다.
- 클라이언트가 서버와의 연결을 끊고자 할 때, 클라이언트는 서버에 `FIN` 패킷을 전송합니다.
- 서버는 `FIN` 요청을 받으면 `ACK` 으로 응답합니다.
- ACK 을 받은 클라이언트는 남은 패킷이 완전히 전달되기까지 일정 시간동안 기다립니다.
- 서버는 마지막 패킷까지 모두 전송한 뒤에 `FIN` 메세지를 전송하여 연결을 종료할 수 있음을 알립니다.
- 클라이언트는 `ACK` 메세지를 다시 전송하여 서버의 연결 종료를 요청합니다.
- 요청을 받은 서버는 연결을 종료합니다.
- 클라이언트는 `FIN` 메세지보다 나중에 도착하는 패킷을 받기 위해 `MSL(Double Maimum Segment Life)` 시간동안 대기합니다.
- 대기 시간이 끝나고 클라이언트는 연결을 완전히 종료합니다.

### 이때 클라이언트와 서버의 상태는 어떤가요?

- 초기에는 서버와 클라이언트가 연결된 상태에 있으므로 양쪽 모두 `EATABLISEHD` 상태를 가집니다.
- 클라이언트는 종료를 요청하는 FIN 메세지를 전송하고, 서버의 ACK 메세지를 기다리는 `FIN-WAIT-1` 상태가 됩니다.
- 이때 서버는 FIN 메세지를 받고 ACK 메세지를 전송한 뒤, `CLOSE-WAIT` 상태가 됩니다.
- 서버의 ACK 메세지를 받은 클라이언트는, 서버의 FIN 메세지를 기다리며 `FIN-WAIT-2` 상태가 됩니다.
- 서버는 자신이 가진 패킷을 모두 전송하고 FIN 메세지를 전송한 뒤 `LAST-ACK` 상태가 됩니다.
- 클라이언트는 FIN 메세지를 받은 뒤, 서버로 ACK 메세지를 보내고 나머지 패킷을 기다리며 `TIME-WAIT` 상태가 됩니다.
- 서버는 클라이언트의 ACK을 받게되면 연결을 종료하기 때문에 `CLOSED` 상태가 됩니다.
- 클라이언트는 일정시간 기다리고 연결을 종료한 뒤 `CLOSED` 상태가 됩니다.

### TCP 헤더에 Squence Number 필드가 필요한 이유를 설명해보세요.

- TCP는 항상 패킷의 순서를 보장해야합니다. 따라서 쪼개져있는 세그먼트에 번호를 붙여서 각 패킷이 따로 도착한다고 하더라도 순서대로 다시 재조합할 수 있도록 합니다.

### 그럼 Sequence Number 필드랑 Acknowledgement Number 필드의 차이는 뭐예요?

- Acknowledgement Number 는 서버로부터 받아야할 다음 데이터의 Sequence Number를 나타냅니다.

### 혼잡제어와 흐름제어의 차이를 말해보세요.

- 혼잡제어(Congestion Control)는 네트워크에 패킷이 과도하게 들어오는 것을 막습니다. 송신자가 데이터를 보내는 속도와 네트워크가 데이터를 처리하는 속도의 차이가 있어 문제가 발생합니다.
- 흐름제어(Flow Control)는 송신 호스트의 속도가 수신 호스트의 처리 속도보다 빨라 수신 호스트의 라우터 큐를 초과하게 되는 상황을 제어하는 것을 말합니다.

### TCP가 흐름제어를 어떻게 하는지 설명해보세요.

- TCP 는 Stop-and-Wait 방식이나 Sliding Window 방식을 사용하여 흐름제어를 수행합니다.
- `Stop-and-Wait`는 송신자가 자신이 전송한 패킷에 대한 ACK 을 받아야 다음 패킷을 전송할 수 있도록 하는 방식입니다.
- `Sliding Window` 방식은 수신측과 송신측에 윈도우라는 버퍼를 두고 알고리즘에 따라 전송할 세그먼트의 번호와 수신할 세그먼트의 수신번호의 영역을 설정하여 한번에 전송할 수 있는 세그먼트의 양을 제한하여 흐름을 제어하는 방십니다.

### 그럼 TCP가 혼잡제어는 어떻게 하는지 설명해보세요.

- 혼잡제어는 크게 `AIMD(Additive Increase Multicative Decrease)` 와 `Slow Start` 를 사용하여 수행합니다.
- AIMD는 네트워크가 혼잡하지 않아 전송속도를 늘릴 수 있을 때는 1 씩 증가시키고, 혼잡제어를 위해 전송속도를 줄일 때는 반으로 윈도우의 크기를 줄여 전송할 패킷의 개수를 줄여주는 방법입니다.

## UDP

### UDP 의 특징에 대해서 설명해보세요.

- UDP는 비 연결형 서비스로 데이터그램 방식으로 데이터를 송수신하는 프로토콜입니다. 신뢰적 통신을 보장하지는 않지만 빠른속도로 데이터를 송수신할 수 있어 스트리밍 같은 빠른 반응이 필요한 서비스에 사용됩니다.

## SSL/TLS

### SSL 에 대해서 설명해보세요.

- SSL은 Application Layer 와 Transport Layer 사이에서 데이터를 암호화/복호화하여 양 계층에 전달하는 암호화 통신 프로토콜입니다.

### SSL의 통신과정을 설명해보세요.

- SSL 은 기존 TCP 3-way handshaking 과정에 SSL Handshaking 을 추가하여 사용합니다.
- 클라이언트는 서버에 client hello 메세지를 보냅니다. 이때 랜덤한 데이터를 생성하여 함께 보냅니다.
- 서버는 요청을 받은 뒤 server hello 로 응답하면서 인증서와 암호화 방식, 서버에서 랜덤하게 생성한 데이터를 응답으로 전달합니다.
- 클라이언트는 서버가 보낸 인증서가 CA에 의해 발급된 인증서인지 확인합니다. 유효한 인증서라면 클라이언트는 대칭키를 생성한 뒤 인증서에 포함된 공개키로 대칭키를 암호화하여 서버에 전송합니다.
- 서버는 자신이 가진 개인키로 암호화된 대칭키를 복호화합니다.
- 이제 양쪽 호스트는 모두 대칭키를 가지게 되었고 이 키를 사용하여 통신시 전달되는 데이터를 암호화하고 복호화합니다.

# Network Layer

## 네트워크 계층과 전송 계층의 차이를 설명해보세요.

- 통신계층은 프로세스간의 논리적 통신을 수행하고, 네트워크 계층은 호스트간의 논리적 통신을 수행한다는 점에서 차이가 있습니다. 따라서 통신계층은 ip주소+포트로 이루어진 특정 프로세스까지 데이터를 전달하는 것이 목적이고 네트워크 계층은 고유한 MAC 주소를 가진 호스트까지 데이터를 전달하는 것이 목적입니다.

## IPv4 와 IPv6 에 어떤 차이가 있는지 말해보세요.

- IPv4는 32비트 주소체계를 가진 IP주소 표현법니다. 32비트로 표현할 수 있는 만큼의 고유한 IP주소를 만들 수 있기 때문에 개수가 한정되어 있고 거의 고갈되어 있는 상태입니다. 이런 문제점을 해결하기 위해 NAT를 사용하여 서브넷을 만들어 IP주소 개수의 한계를 극복하고자합니다. IPv6는 128비트로 주소를 표현하여 거의 무한대에 가까운 IP주소를 만들어 낼 수 있습니다.

## ARP(Address Resolution Protocol)

### ARP 가 무엇인지 설명해보세요.

- ARP 는 IP 주소를 통해 MAC 주소를 알아내기 위해 사용하는 프로토콜입니다.

### ARP 가 동작하는 과정을 설명해보세요.

- 요청을 보낼 호스트가 목적지 호스트의 IP 주소를 알고있는 상태에서 ARP 메세지를 브로드 캐스트합니다. ARP 메세지 안에는 자신의 IP주소, MAC주소, 목적지 호스트의 IP로 채워져있습니다.
- 브로드캐스트를 받은 호스트들은 ARP 메세지 안에 있는 목적지 IP주소를 자신의 IP주소와 비교합니다.
- 자신의 IP주소와 일치하는 것을 확인한 호스트는 목적지 IP주소와 MAC주소를 요청을 보낸 호스트의 주소로 설정하고, 출발지 IP주소와 MAC주소를 자신의 주소로 설정한뒤 유니캐스트로 ARP 패킷을 전송합니다.
- ARP 패킷을 반환받은 호스트는 내부에 있는 MAC주소를 읽어 목적지 호스트와 통신을 시도합니다.

### 최초에 ARP Request 가 브로드캐스트로 보내지는 이유는 뭐예요?

- 두 호스트는 IP주소로 논리적통신을 하지만 실제로는 MAC주소를 알고있어야 통신할 수 있기 때문입니다. 따라서 MAC 주소를 모르기 때문에 네트워크 내에 있는 모든 호스트들에게 목적지의 IP주소가 담긴 ARP 패킷을 브로드캐스트해야 합니다.

## ICMP(Internet Control Message Protocol)

### ICMP 프로토콜을 어떤 목적으로 사용하는지 말해보세요.

- ICMP 프로토콜은 호스트들의 통신 간의 오류메세지를 송수신하기위해 사용합니다.

## Data Link Layer

## 데이터 링크 계층의 역할을 설명해보세요.

- 데이터 링크 계층은 데이터의 오류를 검출하고 흐름제어를 수행하여 호스트간의 신뢰성 있는 데이터 송수신을 지원하는 계층입니다.

## CSMA/CD 가 무엇인지 말해보세요.

- CSMA/CD 는 여러 호스트가 동시에 패킷을 보낼 때 충돌이 나는 것을 감지하고 방지하는 역할을 하는 프로토콜입니다. CSMA/CD는 패킷을 보내기 전에 링크가 비어있는지 확인하고 충돌이 났을 때는 일정시간동안 기다렸다가 다시 패킷을 전송하는 방식을 취합니다.

## 허브와 스위치의 차이를 말해보세요.

- 허브는 한 호스트가 전송한 데이터를 허브와 연결된 모든 호스트에게 전달하고자 할 때 사용합니다. 스위치는 MAC Address Table을 기반으로 특정호스트에 패킷을 보내주는 장비입니다.

## 이더넷이 무엇인지 말해보세요.

- 이더넷은 CSMA/CD를 기반으로 여러 호스트가 데이터를 안전하게 송수신할 수 있도록 돕는 프로토콜입니다.
