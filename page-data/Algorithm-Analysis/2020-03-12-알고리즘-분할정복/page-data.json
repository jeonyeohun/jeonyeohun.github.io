{"componentChunkName":"component---src-templates-blog-post-js","path":"/Algorithm-Analysis/2020-03-12-알고리즘-분할정복/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"b9159d71-ad3e-5cb0-b377-251ed8fa0971","excerpt":"Divide and Conquer Divide and Conquer, 분할정복은 큰 문제를 여러 개의 작은 문제로 쪼개고 쪼개서 해결하는 방법이다. 일반적으로 Divide and Conquer는 recurrence equation으로 표현할 수 있는데, 우리는 이 수식을 통해서 알고리즘의 time complexity 를 구할 것이다.  위와 같은 식을 우리는 recurrence equation 이라고 한다. 식을 보면 T(n) 이 T(n/2) 로 작아지는 것을 볼 수 있다. 이런식으로 n…","html":"<h2 id=\"divide-and-conquer\" style=\"position:relative;\"><a href=\"#divide-and-conquer\" aria-label=\"divide and conquer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Divide and Conquer</h2>\n<p>Divide and Conquer, 분할정복은 큰 문제를 여러 개의 작은 문제로 쪼개고 쪼개서 해결하는 방법이다. 일반적으로 Divide and Conquer는 recurrence equation으로 표현할 수 있는데, 우리는 이 수식을 통해서 알고리즘의 time complexity 를 구할 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 734px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA80lEQVQoz4VRywqDQAz0/z/LiyIqePCgIKiIb3y/H7sdTVuWQts5rLtJZjKJUhRFnHPGGM5lWYZh4DfGcez7ngtATZIk0zSBQmVSHMf4nOdJhLZtqTRNU0qRLnAch+M4WZYhNc/zRRa1QW6aRiT8huR5nuu6ENu2res66iyS2Q26wyB74SL7vi/LsmmaVVXleY6REIVEWZbv+b92hgbp0cIwla7rQRDADrQwJ1QwJ1koimJdV0SohyTaQEJRFMMw4AKDYLeoU1XVsixk9323bRtCYRg+ty3aQKiua/olmqah8x/b4gPaaE7+YQzPj4XR5R15AIQWB3wUL0wlAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eq1\"\n        title=\"eq1\"\n        src=\"/static/10b571ec9f5217ccb32c37fc96e3aad2/c6d67/eq1.png\"\n        srcset=\"/static/10b571ec9f5217ccb32c37fc96e3aad2/5a46d/eq1.png 300w,\n/static/10b571ec9f5217ccb32c37fc96e3aad2/0a47e/eq1.png 600w,\n/static/10b571ec9f5217ccb32c37fc96e3aad2/c6d67/eq1.png 734w\"\n        sizes=\"(max-width: 734px) 100vw, 734px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위와 같은 식을 우리는 recurrence equation 이라고 한다. 식을 보면 T(n) 이 T(n/2) 로 작아지는 것을 볼 수 있다. 이런식으로 n 은 재귀를 거듭할때마다 작아질 것이다.</p>\n<p>이런 recurrence equation을 통해 알고리즘을 분석하는 방법은 네 가지가 있다.</p>\n<h2 id=\"substitution-method\" style=\"position:relative;\"><a href=\"#substitution-method\" aria-label=\"substitution method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Substitution method</h2>\n<p>첫번째 방법은 substitution method이다. 이 방법을 사용하려면 사실 어느정도 알고리즘에 숙련되어 있어야한다. 왜냐하면 분석의 첫 시작을 solution 의 form 을 추측하는 것으로 시작하기 때문이다. 주어진 수식을 보고 어떤 알고리즘일 것이다라고 가정을 세우고 그것이 맞는지 확인해가는 작업을 거친다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1074px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTElEQVQ4y5WTbW+CQBCE+f8/joTEEA0VEBAoRVBehYL26W1CzEUaOh8ud7Czs7N7ZzzfYZ7ncRzzPO/7nmPbttM09QqvYYZGK8sSTtd1dV3v93tWPl6vV3Lxq2kanfx4PJbz7XbLsoy43W7n+z57EkEehoFVcq0qC74VqHZxgYCsOpmUKKDJHoU0TauqulwucRwnSXK/358r+CUTZNs2caLJkbJJ4Xme67rSpFfNZW+IT+wFQfCh4DjO6XRCGT6/DofD8XgkCysaYRgSIBkNUaMrMgnpCoAso8I5K92mfsIGBfzrDWOYJEZQ0lML9UvcqmcNYqlS+IP5nkxV2KMLlmVROfX/g4waPs8KYpumbCXjHNvcsKIoPhXkYmk3ZJUsk/9SwDlz4uMmZaYSRZFpmtRMt5k5XaAK9puUUaNypkoiuba8J+09rj6MjfgBrjLaaBdYQKkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"sub method\"\n        title=\"sub method\"\n        src=\"/static/a70710c37462704c4493c7507e4bc772/18539/sub_method.png\"\n        srcset=\"/static/a70710c37462704c4493c7507e4bc772/5a46d/sub_method.png 300w,\n/static/a70710c37462704c4493c7507e4bc772/0a47e/sub_method.png 600w,\n/static/a70710c37462704c4493c7507e4bc772/18539/sub_method.png 1074w\"\n        sizes=\"(max-width: 1074px) 100vw, 1074px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 예시를 보자. 나는 왜인지 전혀 모르겠지만, 저자는 2T(n/2)+n 을 보고 O(nlogn) 의 복잡도를 가지지 않을까라는 가정을 세운다. 그리고 그것을 증명하기 위 nlogn을 기존 수식에 대입하여 풀고 가설이 사실이라는 것을 증명했다.</p>\n<h2 id=\"recursion-tree-method\" style=\"position:relative;\"><a href=\"#recursion-tree-method\" aria-label=\"recursion tree method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursion Tree Method</h2>\n<p>Recursion Tree Method는 수식을 단계별로 트리모양으로 만들어 복잡도를 계산하는 방법이다. 이 방법은 세 단계로 진행되는데,</p>\n<ol>\n<li>Build a recursion tree.</li>\n<li>Sum the costs within each level.</li>\n<li>Sum the costs of all levels.</li>\n</ol>\n<p>로 나눌 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2ElEQVQoz3WR6QqEMAyE+/4vKfhDEcF6n1vdz51uKRUDhmRyzKSa62FN09R1XZZllmUE8zxfL2b4zvOMIefcuq7LsozjuG0baTLz+Zkf7vs+6dj3fZqmN0JW0+CHYQgrj+NACF5lECQk0gD9MLVhGIQiQYR4gfR1XZfoYgTyezjPc2stEWxcCBo863U8XkcG2VS9bLFBa39GAG3btnguIgAUlfQLv4fJ6dYjs979TZcrwGLlQaPRJhLWQ8KF1ESCoVnM8R8piqKqKhCjXDwY5PHbMhDw5z/7AhWZSv+S4pRzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"recur tree\"\n        title=\"recur tree\"\n        src=\"/static/cc2972597bb3867e48a0d5d6a7b7ff79/c1b63/recur_tree.png\"\n        srcset=\"/static/cc2972597bb3867e48a0d5d6a7b7ff79/5a46d/recur_tree.png 300w,\n/static/cc2972597bb3867e48a0d5d6a7b7ff79/0a47e/recur_tree.png 600w,\n/static/cc2972597bb3867e48a0d5d6a7b7ff79/c1b63/recur_tree.png 1200w,\n/static/cc2972597bb3867e48a0d5d6a7b7ff79/eb1d2/recur_tree.png 1622w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 예를 보면, 3T(n/4) 이기 때문에 총 세 개의 c(n/4)를 만들수 있고 이런식으로 계속 노드를 아래로 늘려가다보면 T(1)이 되는 노드들이 나올 것이다. 이렇게 하면 일단 1단계인 recurstion tree를 만드는 것은 완료이다.</p>\n<p>이제 2단계인 각 level의 cost를 구해야하는데, 그림의 오른쪽에 보다시피 우리가 구한 노드들의 n을 나열해보면 1/4^n 씩 늘어나는 것을 알 수 있다. 따라서 높이를 h로 두었을 때 마지막 노드는 1/4^h n 으로 나타낼 수 있다. 이것을 h에 대해서 정리하면, 우리는 이 트리에 높이를 log<sub>4</sub>n으로 표현할 수 있을 것이다.</p>\n<p>각 레벨의 노드의 개수는 3의 거듭제곱씩 늘어나기 때문에 제일 아래에 위치한 노드들의 갯수는 3<sup>log<sub>4</sub>n</sup> 이 되고 이것을 로그의 성질에 따라 정리하면 n<sup>log<sub>4</sub>3</sup> 으로 나타낼 수 있다.</p>\n<p>따라서 3단계에 따라 모든 cost들의 합을 계산하면 cn<sup>2</sup> 부터 (3/16)<sup>log<sub>4</sub>n-1</sup>cn<sup>2</sup> + 𝛩(n<sup>log<sub>4</sub>3</sup>) 의 합을 구하면 되고 이는 등비수열에 해당하기 때문에 공식을 따라서 계산하면 된다. 그러면 그 결과로 우리는 T(n)이 𝛩(n<sup>2</sup>)의 복잡도를 가지는 것을 확인할 수 있다.</p>\n<h2 id=\"iteration-method\" style=\"position:relative;\"><a href=\"#iteration-method\" aria-label=\"iteration method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Iteration method</h2>\n<p>iteration method 는 우리가 가진 재귀 수식으로 새로운 수식을 만들어 나가는 방식으로 문제를 해결하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLklEQVQoz51Si07DMAzM//8gsNKxptVo0zz7SppXuW0CiSHGxkWKLDvnc6wjL8/PIYTtB1JK8QzvPWLO+SW/rqsQous6lMix7awPa8zWxxBTzhkvcO92u6Io8G6aJmstYwy0ZVnQyxjTti0kibSxneITs7UJ2uUvZdQg6Jw7noFeWmu0ABmyCE7KUuFIFHjPqqqq6xqc7T4QKZU2BrOxvq8q2jTNFTl/4ipzIpdiFTZT7Qvh9yrm7QGQ5tiaYVRmVMP83vX4D/Zxaf83uaZU9ExLPg3mtSjKssQy7iW/CcfmdBqbu73020NjTy5YnwYbjA24Y0r5O26Rt5y2/4JUfJZLaLSj2u35rJQ6HA4wI6UUDru48jd9wsZ19pGNvp8C4mWxWDj8CFdhczDPDfIHu9b0WweFq/gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"iter method\"\n        title=\"iter method\"\n        src=\"/static/a7b79460e3a69b8dea58cd57c2f8d51f/c1b63/iter_method.png\"\n        srcset=\"/static/a7b79460e3a69b8dea58cd57c2f8d51f/5a46d/iter_method.png 300w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/0a47e/iter_method.png 600w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/c1b63/iter_method.png 1200w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/d61c2/iter_method.png 1800w,\n/static/a7b79460e3a69b8dea58cd57c2f8d51f/191e2/iter_method.png 1836w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 예시를 보자. s(n) = c + s(n-1) 의 식이 성립하기 때문에, 우항의 s(n-1)은 c + s(n-2) 로도 나타낼 수 있다. 이런식으로 식을 반복적으로 만들어보면 우리는 ck + s(n-k) 라는 정규화된 식을 도출 할 수 있다.</p>\n<p>초기식에서 우리는 s(0) = 0 이라는 정보를 가지고 있고, k는 항상 n보다 같거나 작아야 한다. 따라서 k가 n 과 같다고 가정했을 때, 우리는 최종적으로 s(n) = cn 이라는 식을 도출 할 수 있고, 최종적으로 이 수식의 시간복잡도는 O(n) 이라고 결론내릴 수 있게 된다.</p>\n<h2 id=\"master-method\" style=\"position:relative;\"><a href=\"#master-method\" aria-label=\"master method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Master Method</h2>\n<p>Master method 는 재귀식을 특정한 형태로 만들고, 그 형태 안에서 정보를 얻어 준비되어 있는 조건에 맞는지 확인하는 방법이다. 하지만 모든 재귀식이 이 조건으로 판단 될 수는 없고 주어지는 세 가지 조건에 모두 해당하지 않는 재귀식이 있을 수 있다.</p>\n<p>Master theorem 은 다음과 같다.</p>\n<p>a >= 1, b > 1, 함수 f(n) > 0 이고 T(n) 이 양수로 정의된다면,</p>\n<center>\n<br>T(n) = a T(n/b) + f(n)\n</center>\n<br>\n위 수식의 T(n)은 아래의 조건에 따라 구분될 수 있다.\n<ol>\n<li>f(n) = Օ(n<sup>log<sub>b</sub>a-ε</sup>) 의 형태를 가질 때, ε이 0보다 크다면, T(n)의 복잡도는 <strong>T(n) = 𝛩(n<sup>log<sub>b</sub>a</sup>)</strong> 이다.</li>\n<li>f(n) = 𝛩(n<sup>log<sub>b</sub>a</sup>) 의 형태를 가질 때, T(n)의 복잡도는 <strong>T(n) = 𝛩(n<sup>log<sub>b</sub>a</sup> lg n)</strong> 이다.</li>\n<li>f(n) = Ω(n<sup>log<sub>b</sub>a+ε</sup>) 의 형태를 가질 때, ε이 0보다 크고, 1보다 작은 c에 대해 f(n) 이 f(n/b) ≤ cf(n)의 조건을 만족한다면, T(n)의 복잡도는 <strong>T(n) = 𝛩(f(n))</strong> 이다.</li>\n</ol>\n<h2 id=\"proof-by-induction\" style=\"position:relative;\"><a href=\"#proof-by-induction\" aria-label=\"proof by induction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof By Induction</h2>\n<p>수학적 귀납법을 통해 알고리즘을 분석하는 방법이다. 수학적 귀납법은 크게 1) Base case, 2) Inductive hypothesis, 3) Proof of goal statement 의 세 단계로 이루어져 있다.</p>\n<ol>\n<li>Base case:\n이 단계에서 우리는 가지고 있는 방정식이 n=0 이거나 n=1 일 때 성립하는지 확인한다.</li>\n<li>Inductive hypothesis:\n귀납법을 수행하기 위해서 가정을 세워야 한다. Base case 를 기준으로 가설을 세우면, 0보다 큰 모든 n에 대해서 우리가 가진 방정식이 k ≥ 0 와 k &#x3C; n 을 만족한다는 가정을 세울 수 있다. 따라서, 이 가정에 따라 방정식은 k=n-1 일 때도 성립할 것이다.</li>\n<li>Proof of goal statement:\n이 단계에서는 우리가 세운 가정에 따라 방정식이 실제로 성립하는지 확인하는 작업을 가져야한다.</li>\n</ol>\n<p>귀납법을 이용한 방법은 항상 쉽지 않다. 왜냐하면 중간단계에서 세우는 가정이 조금만 틀리면, 그럴듯 해보이지만 반례가 존재하는 가정이 만들어지고 실제로는 false 이지만 true인 명제라고 착각하기가 쉽기 때문이다. 아래 예를 통해 더 자세히 알아보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB4ElEQVQoz31SCY6jMBDk/4+LMjBDuE2AQDDYHMEJd08FtNloVzMtaDV2H1XVaMePD+N0ipIkSdNLnnued80y27bv9/s4jnme+75flqWu67iyLOtwOLiuez6fgyDQxq5TQTALsdb1WBTzPC/Lsvt1XV+BUmoYhr7v0RTBuJlGSpFpDl9fo+vOljUNwzSO8zTBw6F496in/0zD2xN5WeanadX34nbzo6hoGtk0aZrGccwYu16vVVUh89ViD7bJlkW2/fTnM/k+fX7S6bQkyZ5FP5tGy/IoyzpJ2iyTcSyDQDBWR1FXlpjW1LUQAkHXdbfNQB4q4ATkn7CHafIZw3PUddO2PcYM07Rd93g8Ql7DMMIwBH7ICwpYS13XbdtCvGcxdIP02AeSQA/rQSpOLpvhE1dRFEEC3AIIyv5wJgIA3GGfWCA2jN6o2eegCzo6jvOSDZVvnNFjXQFDCtHAVxV2g3a8KAAP2ZiMSs45AnB+11yjtiXHIcYoDEnXyfOeshsGuS7F8e+CP9VWGJjnFeeLUp2UPElklmGi5FxKuUsNOBgO2uAMmH9/kk4pgEyzrBCCl+UFO8OG0IVz8ARtCIaapmkA+/F4QOC3P6zvQQ8ZSEWAJIzCPnGCyaBab4bh/8D+BtiDEeezAdqpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proof induction\"\n        title=\"proof induction\"\n        src=\"/static/ec63514bc5c17787c0767ae3e76ddc15/c1b63/proof_induction.png\"\n        srcset=\"/static/ec63514bc5c17787c0767ae3e76ddc15/5a46d/proof_induction.png 300w,\n/static/ec63514bc5c17787c0767ae3e76ddc15/0a47e/proof_induction.png 600w,\n/static/ec63514bc5c17787c0767ae3e76ddc15/c1b63/proof_induction.png 1200w,\n/static/ec63514bc5c17787c0767ae3e76ddc15/41870/proof_induction.png 1788w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>","frontmatter":{"title":"[알고리즘 정리] 분할 정복(Divide and Conquer)","date":"March 12, 2020"}}},"pageContext":{"slug":"/Algorithm-Analysis/2020-03-12-알고리즘-분할정복/","previous":{"fields":{"slug":"/Operating-Systems/2020-03-10-운영체제-컴퓨터구조/"},"frontmatter":{"title":"[운영체제] 운영체제의 정의와 컴퓨터 구조(Operating System and Computer Architecture)","category":"Operating-Systems","draft":false}},"next":{"fields":{"slug":"/Operating-Systems/2020-03-14-운영체제-모드/"},"frontmatter":{"title":"[운영체제] 컴퓨터 시스템의 종류와 운영체제의 실행모드(Computer Systems and Operation Mode of OS)","category":"Operating-Systems","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}