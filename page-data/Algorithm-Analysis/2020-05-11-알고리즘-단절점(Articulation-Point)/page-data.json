{"componentChunkName":"component---src-templates-blog-post-js","path":"/Algorithm-Analysis/2020-05-11-알고리즘-단절점(Articulation-Point)/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"f8dfb782-a40d-5648-9d82-fb7bddaceea7","excerpt":"Articulation Point (단절점) 방향이 없는 그래프에서 어떤 정점(vertex)를 제거했을 때, 두 개 이상의 그래프가 형성되게 하는 정점을 Articulation Point 라고 한다. 조금 더 쉽게 이야기하자면, 이 정점이 두 그래프의 연결점이 되는 것과 같다. 다음 그래프를 한번 살펴보자.  이 그래프는 정점 C…","html":"<h1 id=\"articulation-point-단절점\" style=\"position:relative;\"><a href=\"#articulation-point-%EB%8B%A8%EC%A0%88%EC%A0%90\" aria-label=\"articulation point 단절점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Articulation Point (단절점)</h1>\n<p>방향이 없는 그래프에서 어떤 정점(vertex)를 제거했을 때, 두 개 이상의 그래프가 형성되게 하는 정점을 Articulation Point 라고 한다. 조금 더 쉽게 이야기하자면, 이 정점이 두 그래프의 연결점이 되는 것과 같다. 다음 그래프를 한번 살펴보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 922px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABAElEQVQ4y5WTiQ6EIBBD+f//9Ir3fcumTcYgoKskBBzY+jp1lf44juPgum2bnufZqasvQvKjdV11nuecfd9fztUXKlmnaaLYvu9czXP1VsgkbNtWB0GgkySh+CtCm0oGxJqmoRD29p1XhOjZOI666zpdliVr2GdZ5vRX/QsAaRZFwQmL8gKIoQbhR8u2VUkUaxzHpzAEl2XhsxOKSWQHAIIwDClmBlBVFUXlW7wQPgVQ1zVtIwjfndtQTIvDMJAMFBgIBIS2A58zZYshRdBEUcQa+oQeQtyk9JGehHIIEljE3wlE2KdpyimfzF17bi2DAslJAL7anZhDaF/0WftH+APtCZ5kawss8wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/029edadc4cd8ae07c415714ae13eb3c9/6da96/1.png\"\n        srcset=\"/static/029edadc4cd8ae07c415714ae13eb3c9/5a46d/1.png 300w,\n/static/029edadc4cd8ae07c415714ae13eb3c9/0a47e/1.png 600w,\n/static/029edadc4cd8ae07c415714ae13eb3c9/6da96/1.png 922w\"\n        sizes=\"(max-width: 922px) 100vw, 922px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>이 그래프는 정점 C를 기준으로 두 그래프로 나눌 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 922px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABSUlEQVQ4y52TSU/EMAyF8/9/EyAOiAsgbggJmOE0pXRN0m26Gb9Ao5KuYMnKTJt8tZ9fBO2Mvu9tIrTWJKWkruvse4T4D6woCgtE7gKOAS4QkCiKSCllcjdwvA6B6tI0NVDf9ycfF1ut2pVTZxnFcWyfoW33o2JLr75tqXh+Inl/R+rTt/uSJDEVtvx+tWW31TbPSd/eUHp9SerwRpL/e6eT1Q/tb2pooUi2xfnDo+p4oLosqeGKcoZiKGEYmt+LQHeyxesL6ccHalg7N5qmobqulzV0teMTpNDq1QVV78fvPVztrz0z58SS1zJuJWHNNA+kq6qJvpPhjVt2vTbcgpafyxlrrIWtEHcSugwwxJkrg/iuvqvAAYaDSM/zDLhiWBAEJvUfqhTDxHCwZFtghWlxI2AL+Mz12q6W4SdAqp8BDFoCNmePpfgCkC7qYqJd9SwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"2\"\n        src=\"/static/860a5c83d74074e3f8f88d698967e140/6da96/2.png\"\n        srcset=\"/static/860a5c83d74074e3f8f88d698967e140/5a46d/2.png 300w,\n/static/860a5c83d74074e3f8f88d698967e140/0a47e/2.png 600w,\n/static/860a5c83d74074e3f8f88d698967e140/6da96/2.png 922w\"\n        sizes=\"(max-width: 922px) 100vw, 922px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>이런식으로 어떤 두 그래프의 연결지점이 되기도 하고, 또 다르게 생각해보면 이 정점을 제거했을 때, 완전히 다른 두개의 그래프가 생성되기도 한다. 이런 정점을 Articulation Point 라고 부르고, 우리 말로는 단절점이라고 한다.</p>\n<h2 id=\"algorithm-concept\" style=\"position:relative;\"><a href=\"#algorithm-concept\" aria-label=\"algorithm concept permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithm Concept</h2>\n<p>그렇다면 단절점을 찾기 위해서는 어떻게 접근해야 할까? 우선 이전 강의에서 우리는 방향이 없는 그래프에서는 Tree Edge 와 Back Edge 만이 존재할 수 있다는 것을 증명했다.</p>\n<h3 id=\"사실-내가-까먹어서-다시-적는-edge의-종류\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%8B%A4-%EB%82%B4%EA%B0%80-%EA%B9%8C%EB%A8%B9%EC%96%B4%EC%84%9C-%EB%8B%A4%EC%8B%9C-%EC%A0%81%EB%8A%94-edge%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"사실 내가 까먹어서 다시 적는 edge의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사실 내가 까먹어서 다시 적는 Edge의 종류</h3>\n<ol>\n<li>Tree Edge: 현재 정점으로부터 새로운 정점에 방문할때 생기는 Edge</li>\n<li>Back Edge: 트리에서 자손이 되는 노드가 조상의 노드와 이어질 때 생기는 Edge</li>\n<li>Forward Edge: 조상 노드가 자손 노드와 이어질 때 생기는 Edge</li>\n<li>Cross Edge: 현재 탐색중인 (서브)트리가 탐색이 끝난 다른 (서브)트리와 이어질 때 생기는 Edge</li>\n</ol>\n<p>다시 본론으로 돌아와 정리해보자면, 방향이 없는 그래프를 탐색할 때, 새로운 노드가 탐색되는 경우, 그리고 자손 노드가 조상 노드의 이어지는 경우만 존재할 수 있다. 이 특성을 기억한 채로 다음 그래프를 살펴보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 732px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 102%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAABrElEQVQ4y5VVDWvCMBD1//+osa0w9gErwsomIgrWfldrbetHa295wXMxS6sehCT28vLu7l0ckGJt257XVVXRdru9+KYO3Z9tYALMsoySJKE4jinP8wvA06YT1AgYRREdDgeq65oWiwUdj8c/5vs9tYaIegFXq5UcYOp5HsXignyzoWg6pejjnYKfb2pOl1xlyA4IlcOFBUFAnvVE+YtF4eMD5Wl6HdBUHF7XglFof1IiwFzrmaqiuI+hqapRGNLX2yuVSqF6c6izUg8sl0s5UpHXLh8joO6IORTMNqIoqPp8Pr8dUHfaC4mgGLvdToJhDX2C6c0hs1NZlpJZ0zRyD5EDGPtUVBg6vaso4/FYMmRbr9eSHUKH8KlD3AMTGJigQ3BYPQTGo9Ho/l5Gl9i2LQH0Hkfn6LLqZAhD3yK04XBIvu+fcwWbzWaSIV6ifw+GCqh+QDHA0HVdySg76Q5pmEwm5DjO+bfekNVwIRE2sOVwkQKEDNmwz1WGYIYD/Npgj2qz9mCF6OOir5dVQBxG2MgTZjCBZACMGZdAk8jvzZ2iGwrFfwmYMVij+plf12EetjL98h4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3\"\n        title=\"3\"\n        src=\"/static/6f537246fe2517143e1576981c75a757/d0cc0/3.png\"\n        srcset=\"/static/6f537246fe2517143e1576981c75a757/5a46d/3.png 300w,\n/static/6f537246fe2517143e1576981c75a757/0a47e/3.png 600w,\n/static/6f537246fe2517143e1576981c75a757/d0cc0/3.png 732w\"\n        sizes=\"(max-width: 732px) 100vw, 732px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 그래프를 보면 만약 C를 루트노드로 하는 서브트리에 B로 연결되는 Back Edge 가 없다면, 우리는 B를 C 서브트리의 단절점이라고 정의할 수 있다. 왜냐하면 C 노드의 밑에 위치한 모든 노드들은 C을 거치지 않는다면, 절대로 B에 도달할 수 없기 때문이다. 따라서 만약 B 노드를 이 그레프에서 제거하게 되면 기존 그래프와 연결이 끊어지고 C를 루트로 하는 별도의 새로운 그래프가 생성되는 것이다.</p>\n<p>구현이 정말 쉬울지는 두고봐야겠지만 우리는 결국 DFS를 통해서 모든 정점들을 순회하면서 Back Edge를 통해 연결되지 않는 정점을 찾으면 된다.</p>\n<h2 id=\"algorithm\" style=\"position:relative;\"><a href=\"#algorithm\" aria-label=\"algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithm</h2>\n<p>그럼 본격적으로 알고리즘을 살펴보자.</p>\n<h3 id=\"pseudo-code\" style=\"position:relative;\"><a href=\"#pseudo-code\" aria-label=\"pseudo code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pseudo Code</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">For all vertex v under vertex y, check back edge vw\n    initialize &#39;back&#39; to discover time of v\n\n    when encountered with back edge vw\n    back of v = min (back of v, discover time of w)\n\n    when backtracking from v to u,\n    back of u = min (back of u, back of v)\n\n    when backing up from root of the sub-tree(z) to its parent node\n        if all vertices in z has higher back then discover time of d y, y is a Ariticulation Point Candidate\n\n        else if there is back value lower than discover time of y, y cannot be Articulation Point</code></pre></div>\n<p>영어로 써두니 더 복잡해 보인다.. 정리해보자.</p>\n<ol>\n<li>일단 우리는 모든 정점을 다 순회해야 한다. 정점을 방문할 때마다 discover time 을 back 이라는 변수에 기록한다. 이 변수는 각 노드마다 연결되어 있는 트리에서 제일 위에 위치한 조상노드의 discover time을 기록하게된다. 이게 무슨 의미인지는 계속 진행해가면서 이해해보자.</li>\n<li>어떤 정점(y)에 대해서 그 하위에 존재하는 모든 노드를 탐색하면서 Back Edge 를 검사한다. Back Edge 는 자신과 연결된 노드 중, 이미 방문했던 노드를 확인하면 된다. 이미 방문했던 노드가 발견되면 현재 정점의 back 값과 back edge를 만드는 부모노드를 비교해 더 작은 값을 back 값으로 업데이트 한다.</li>\n<li>각 노드가 DFS로 탐색을 마치고 더 이상 진행할 자녀노드가 없어 백트랙 하게되면, 탐색을 마친 부모 노드는 방금 탐색을 마치고 돌아온 자녀노드가 가진 back 값과 자기 자신의 back 값을 비교해서 더 작은 값을 자신의 back 값으로 만든다. 이 시점에서, 탐색을 마친 노드는 자신의 하위에 있는 노드들과 연결된 노드 중 가장 높은 level에 있는(루트노드와 제일 가까운) 노드의 discovery time을 가지게 된다.</li>\n<li>위 작업을 루트 노드로 돌아올 때까지 반복하게 되면, 마지막에 가지게 되는 back 값이 단절점이 되는 노드의 discovery time이 되기 때문에 Articulation Point 를 찾게 될 것이다.</li>\n</ol>\n<h3 id=\"example\" style=\"position:relative;\"><a href=\"#example\" aria-label=\"example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 732px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABZ0lEQVQ4y4WU2Y6DMAxF+f+PRPBCW9aWHdri0bHGNKRhxlIEcbxcXzuJ5Fe2bdMV+vfl7Ix95B+cBXWXa/d6vaTrOnk+n7qPQpkxCiH37ZA8z+V+v8vtdpN1XT8IzahpGinLUoqikPf7vTv2fa/6ZVl2XZZl8ng8FB1+2BxKHsdR6rrWb9u2cr1eZZ5nDQQSgl0uF11VVaktNpT8hRBBATILjDH/BKAsEKMnmQlJkiRR351DAlp5lEE2SjHhjKDoQebSZEn2LrsED8OwH/qJQAhPPuc0kKoOYwNsHCjRAvij4jr5Y3ZACOkQTnbKCg0uSWiMn8gamabph0MMUQKdoCTwGwWvlsyVaZoUDE3iq102JU2AdLccknBGQqMEZ2zZx3GsI2PzSw+UQ1BhaDfEgqKnq3BMUJDixAAzzFBhNwWO8Y/OrpV7cwiKo3sl3SpAac2MQkT7X5D+9VB8vTah5yn0RP33EiE/L9bkz8APGHwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4\"\n        title=\"4\"\n        src=\"/static/24b69b8d214d7cd6e7b1a85da24fcd31/d0cc0/4.png\"\n        srcset=\"/static/24b69b8d214d7cd6e7b1a85da24fcd31/5a46d/4.png 300w,\n/static/24b69b8d214d7cd6e7b1a85da24fcd31/0a47e/4.png 600w,\n/static/24b69b8d214d7cd6e7b1a85da24fcd31/d0cc0/4.png 732w\"\n        sizes=\"(max-width: 732px) 100vw, 732px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위 그래프의 단절점을 찾아보자. 탐색을 시작할 노드는 임의로 A로 정하자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 904px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAABYklEQVQ4y52U6a6CMBCF+/4PScSEgAiyCCibY74mw20r8OM2aSiznDmztEb+sT6fz/bVrcscGbmyM7DwbPYUYdRQFurcszlicyZXWV3Xcrvd5H6/y7Isfymrwev1kqqqpG1bDwTjrus8cGyLopDn82mB2VvKrHmeJc9zG42vGuAICwIhJxjnNE3tJlBZltI0jQ/4fr/l8XhI3/fW6XK5WNDr9WqNcYRRlmUyjqP1GYZB4ji2gLtNSZLkpyYwhBmpoVP5uq72SxA9e02Zpsk6wlQNXCeYUpawMQTHdwPUIqPQVEInSqHMwu6jcwMZrQvpKqtw7mAezqhbJg+QCBSfwipDdzx01vZmEh86TUAtj8FBRyYExAE5GVBbbRKTgI7s+PfmEAUMGAsXjJFg3uguYFEUWXCVqR92OuA/N8WtDSnQKIxxDG8PCxIE0aE+vMvu7QFI2R89Wa7cHL0kZ4/C2ev0BXGEM1DgfwjcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"5\"\n        title=\"5\"\n        src=\"/static/77bb6a7368e0ea6d241436939c09e8e4/d9217/5.png\"\n        srcset=\"/static/77bb6a7368e0ea6d241436939c09e8e4/5a46d/5.png 300w,\n/static/77bb6a7368e0ea6d241436939c09e8e4/0a47e/5.png 600w,\n/static/77bb6a7368e0ea6d241436939c09e8e4/d9217/5.png 904w\"\n        sizes=\"(max-width: 904px) 100vw, 904px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>먼저 DFS로 그래프를 순회하면서 Discover Time 을 back 값으로 지정해준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 904px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACAUlEQVQ4y51UaZOaQBDl//+qJFvJrtkYYxC8VlkOAR1OUfFi3jZDuBb1Q6aKYmqgX79+/Xok/MfivHzz1pMvqf6Jt35qnnUB+WPARz8U+3aie8nyM+kRm8/g5VmWZWJ/OBwgzyzIU0vsOwyv1wvstU9PQEHXFvh+t0NG3xvpMFnY+P7XwbOywWTpiDOpyUAzN/jS1/H1t077tQDlxGahO/ip2BhOLMRxjDAM4fsM8lgjsDV+yA7edLdgKABFwitlcfGieuiNPQyUpQgyTYPAVnghFj2VYTLXcDqmouw84WxpQZ29U3XXbsmeH6A3XGA4XWGb7KrSlDcbzyMXPdlEstu3ND+fT9jGUbspWVZ8ZIwhPewr/UrxL2kKZ6lXSZoy7akZQRDUgLXoidCmZYtSjj2xojI/W6wEzHWtANcswGi+gjpdiPL4jaAcMKNA3mBXso/CAEnSAPyl2nga2ugpLoIw6pR0Oh2ROs5Nr0Zxgr6iU/cNpOmxaEoO2J/H1MkasNQ03lKAauFVNpBXUjThjB15Mm/En7FJrmDkCr+2DfNCjMjtK4dVg18ymWoOecwVQa+yBo9tyAk+JdoKwNHMoO4XPjRt1rwceGfc8uVuAjwN3vFtYGBpuJ3RvBBbjc5zMP5PU+nW8NdacYSkk+dHVcCt+e5cDrfAqgm6c23du50+AFx+JZQdYWEpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"6\"\n        title=\"6\"\n        src=\"/static/0ae356a1c1500a6d9234b0aea448b4cd/d9217/6.png\"\n        srcset=\"/static/0ae356a1c1500a6d9234b0aea448b4cd/5a46d/6.png 300w,\n/static/0ae356a1c1500a6d9234b0aea448b4cd/0a47e/6.png 600w,\n/static/0ae356a1c1500a6d9234b0aea448b4cd/d9217/6.png 904w\"\n        sizes=\"(max-width: 904px) 100vw, 904px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>DFS로 탐색하기 때문에 더 이상 진행할 수 없을 때까지 진행하다보면 E 노드에서 C 노드로 탐색을 하려는 시도를 하게 된다. 그렇지만 C는 이미 방문된 상태이기 때문에 진행할 수 없다. 즉, C 와 E 사이에 Back Edge가 존재하는 것이 확인된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 904px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+0lEQVQ4y51UiXKiQBD1/78ralYrWQ2gBohGGS650chR4ttmUA4lld2dqilqmOnud/TMAP8xLpdL/W3PcgzaG/eH+oLa//sKDe4rfo8E19lOfAEzHSifJpIkaRC2gw/HL3h+ROvirsgjIsN2MXrTMRQsCLLOz3QQ+kGE57cdnmYaPrZWBYlGFB8xW2kQFcaRnE4nxFEI6X2NESUbi3v8XjIOYlAmK4oqcL2zMZb2eKb5S9hib1uIwgCv0pb/H0s2ZpKKOA7xRUmzNMVS1fFC+yUYTrktdBQfMHxVMZxtoRkOp5CmCSRCNhJMPM0ZNNPt0E6TEzzXaUypEFZ6xXEM13WRZllNtxwZrecLFTsqUhTnjrYnkiAIwq7LfEFJLctuOdwEnc9nhIHfcb9OSNR9328SpqRDWVlWN5xeXy/GJEUURehrsTzPuEF1QlHRySUyQ2DYu8EDAu6+RzIkCR4vQQF5rUNYbbgs3JSXBcNk5XEXt6yifHO9IKryxsBE+ITteHfXokzGeNuUc/lhVn1oOz6m4g6izOoqxRWBYbmE3MSUik0lDYxpZJoH297zdlooO95KJRhJMcrImylFr+ClBBPRwHzpUmPryLOUm3XrijzPCRlRJjBHumFNH/Y8EO3r9U60D9eAHx+HjqOtQ98F/NXz9S/vXacDevb/AGJxJSoOQ42eAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"7\"\n        title=\"7\"\n        src=\"/static/a9d4d16f4e605ff02dccd67524ba9e84/d9217/7.png\"\n        srcset=\"/static/a9d4d16f4e605ff02dccd67524ba9e84/5a46d/7.png 300w,\n/static/a9d4d16f4e605ff02dccd67524ba9e84/0a47e/7.png 600w,\n/static/a9d4d16f4e605ff02dccd67524ba9e84/d9217/7.png 904w\"\n        sizes=\"(max-width: 904px) 100vw, 904px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>따라서 미리 정해둔 규칙에 의해서 E는 자신의 back 값과 C 노드의 Back 값 중 더 작은 값을 자신의 back 값으로 업데이트한다. 따라서 E의 back 값은 3이 되었다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 904px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACA0lEQVQ4y51Ui5KaQBD0/7/rTk283Cki6GFUFESXN1eK8urMLqggJJVkqrbYmtnpmdlutof/sKIo7t/64tarH6Bd60BXUjOnWagCbB/i2wZoB3ieZ9iaDEvdwvV6fXR464xbFH3B80Phe+7+2TjYq7SnZWH+cy/O9OqjMMfHYLLFy3gL3WD3RJcKfKg7KEsTSXLF6XRCFAaQ1BUG8hH96QFTjQCLvATM8xLwc3NAX2YYzBhG0zVsdoTvuRjJuvB9U21IioavKMT5fEYcx5A1A++KjpAmEyPXO3S9AC8/luiPdVjMEyOczydIi53o4nVi4CD8D4vjEzzXEfu8KG4d5sIRBAFc160uuKglxRjLGgzLEWzVm+Ax3/ebLHNL0wTHI2tI4JZ0uVzEmM8y4sZH9zzvAcgdGyJAW66RpWlLuNzCKEIYRp2xlEjiBN0BJwtDMDWcGpVc0BKxY7NGsVssy1KSyw7yYkMTlvHem7LH97mLocJgWnZ5uRXrSZJgvqK4tBbSqVtGV6QuOVkWhqQAjRQiADnISN6SxgxR8cYWN52E2yfRjhQbb7MtrL0J23HAGBNykhY63lUHE2pIXVXCLufIO8kwDw5GswM+CFD6NJFTQV4sq1TByZqRDvnibN91+AxUPH5u7PY2Cd4iNuNOUlqPQ9fr8qeEv3q+/uW9K/f4bfwXRPIlNnINDV4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"8\"\n        title=\"8\"\n        src=\"/static/2be4d53f2daabe9d36b5f84b9a8ba740/d9217/8.png\"\n        srcset=\"/static/2be4d53f2daabe9d36b5f84b9a8ba740/5a46d/8.png 300w,\n/static/2be4d53f2daabe9d36b5f84b9a8ba740/0a47e/8.png 600w,\n/static/2be4d53f2daabe9d36b5f84b9a8ba740/d9217/8.png 904w\"\n        sizes=\"(max-width: 904px) 100vw, 904px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>E 노드로부터 백트랙하면서 부모노드인 F는 자신의 back 값과 E의 back 값인 3을 비교하게 된다. 이 경우에는 E의 back 값이 3, F는 5였기 때문에 F의 back 값은 3으로 업데이트 된다.</p>\n<p>이 과정을 계속 진행하다보면 그래프의 back 값은 다음과 같이 채워진다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 904px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+0lEQVQ4y51UiZKiMBD1/39ramccj3FHwK1xXeRSbuTyAuLbDgqCYNXspiqVq/t1p99LBviPdrlc6rHZeRs8M6AV+PDo1LTtCzR4ZnAHvfVGQMautsfjEcv1FmvdRlEUPRkyBi8IEUZJ53oAe8wHi9UWb6KNV8GEtnWvgM1ryBTpZabi9VOF4wW1q7ZxMBI1rBQTeZ4hjmN4ro2xuMbPhYuxYJW+NSBveXbGfGliSAa8fy7+IAoD6LqBd3GDKe39mG8gKyr2+z2yLEOS7jEl0MXKKNedDDXDwsuHjImkIU7Sci8KQwIzKICDoaBjfzi2Lh74HpWqaJNSFdl1HCRJUkdj7Fo3x/UgfCnYhXFLDaWP55F9fgesInGgHWXTJKNy4mfHQ9rRYAnounUCJWCwi/CbU69oHaBqDIIAp9OpdV5lvwt8Lo874Eg0iHYLY0nH+XzugLIih2Vue4SPkpQPUYasWbR3BR28SyYmyx3e5gYV/NDKLI4TYn6DCTGZErPNcsRxhNkvHUPSIWfftP0rIEfnrKqkteq5sRugRMIdCjZGJJmZJMP3HDhEnO/7NPfIT4X0FZCNiW0FeHsivWQsSchTySatWVhRYN4Kql11HsUphKVeXplVT+/xnTavXFD9FMOGSp3dtNZ9kj2fQx/YM4dvfV//8t/1zZvrv7E3JZEZ89ODAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"9\"\n        title=\"9\"\n        src=\"/static/242937eb0e585a02588fd40740afbb3a/d9217/9.png\"\n        srcset=\"/static/242937eb0e585a02588fd40740afbb3a/5a46d/9.png 300w,\n/static/242937eb0e585a02588fd40740afbb3a/0a47e/9.png 600w,\n/static/242937eb0e585a02588fd40740afbb3a/d9217/9.png 904w\"\n        sizes=\"(max-width: 904px) 100vw, 904px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>백트랙을 진행하면서 가장 작은 back 값인 3으로 C까지 진행되었다. C의 Discovery Time이 C의 서브트리에서 올라온 back 값과 같기 때문에 C 아래로는 C 위에 있는 노드들과 연결된 노드들이 없다는 것을 알 수 있게 된다. 따라서 C는 Articulation Point 가 된다.</p>\n<p>하나의 단절점을 찾았지만 아직 DFS는 끝나지 않았다. C의 탐색이 마치고 B로 백트랙하게 되면 더 작은 값인 2가 그대로 유지될 것이다. 그런데 한가지 의문점이 생긴다. 위 그래프에서는 결국 마지막까지 돌아왔을 때 중간에 어떤 과정이 있었든지 루트노드가 항상 최소의 back값이 된다. 뭔가 이상하다.</p>\n<p>그래서 Articulation Point 를 판단하는데는 한가지 조건이 추가된다. 어떤 정점이 articulation point 가 되려면 반드시 <code class=\"language-text\">두 개 이상의 서브트리</code>를 포함하고 있어야 한다. 따라서 A노드는 B노드 하나만을 자녀노드로 가지기 때문에 단절점의 조건을 만족하지 못하고, 해당 지점 이전까지 가장 작았던 back값에 해당하는 B가 또 다른 단절점이 된다.</p>\n<p>따라서 이 그래프에서 단절점은 B, C 두 개가 있다고 할 수 있다.</p>","frontmatter":{"title":"[알고리즘 정리] 단절점(Articulation Point)","date":"May 11, 2020"}}},"pageContext":{"slug":"/Algorithm-Analysis/2020-05-11-알고리즘-단절점(Articulation-Point)/","previous":{"fields":{"slug":"/Algorithm-Analysis/2020-05-08-알고리즘-임계경로(Critical-Path)/"},"frontmatter":{"title":"[알고리즘 정리] 임계 경로(Critical Path)","category":"Algorithm-Analysis","draft":false}},"next":{"fields":{"slug":"/Problem-Solving/2020-05-12-백준-단절점/"},"frontmatter":{"title":"[백준 알고리즘] 11266번: 단절점","category":"Problem-Solving","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}