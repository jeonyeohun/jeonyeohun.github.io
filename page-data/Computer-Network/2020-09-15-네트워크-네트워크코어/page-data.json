{"componentChunkName":"component---src-templates-blog-post-js","path":"/Computer-Network/2020-09-15-네트워크-네트워크코어/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"3ef8d779-4d62-5caf-8ee5-95ecc600eddf","excerpt":"참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음 데이터를 이동시키는 방식 링크와 스위치를 통해서 데이터를 이동시키는 방법은  과 으로 나뉜다. Packet Switching(패킷 교환) 어떤 두 end system…","html":"<p><em><strong>참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음</strong></em></p>\n<h2 id=\"데이터를-이동시키는-방식\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%B4%EB%8F%99%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"데이터를 이동시키는 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터를 이동시키는 방식</h2>\n<p>링크와 스위치를 통해서 데이터를 이동시키는 방법은 <code class=\"language-text\">Circuit Switching(회선 교환)</code> 과 <code class=\"language-text\">Packet Switching(패킷 교환)</code>으로 나뉜다.</p>\n<h2 id=\"packet-switching패킷-교환\" style=\"position:relative;\"><a href=\"#packet-switching%ED%8C%A8%ED%82%B7-%EA%B5%90%ED%99%98\" aria-label=\"packet switching패킷 교환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Packet Switching(패킷 교환)</h2>\n<ul>\n<li>어떤 두 end system이 정보를 서로 송수신하게 되면 해당 데이터들은 <code class=\"language-text\">패킷</code> 이라는 작은 세그먼트로 나뉘어서 전달되게 된다. 그리고 전달되는 과정에서 앞서 공부했던 <code class=\"language-text\">Communication Link</code> 와 <code class=\"language-text\">Packet Switch</code> 를 거쳐서 데이터는 이동된다.</li>\n<li>패킷 교환은 여러 사용자들이 네트워크 자원을 공유하고 이 자원들은 요청이 들어올 때마다 할당된다. 이런 자원할당 방식을 <code class=\"language-text\">on demand</code> 방식이라고 한다.</li>\n<li>페킷 교환은 회선 교환처럼 미리 자원을 예약하거나 연결을 설정하지 않아도 되기 때문에 효율적이지만 여러 리소스들이 한번에 들어왔을 때, 감당을 못할 수도 있다. 이런 현상을 <code class=\"language-text\">conjestion</code> 이라고 한다.</li>\n<li>패킷은 링크의 bandwidth를 하나의 패킷에 대해 모두 사용하기 때문에 링크의 최대 전송 속도와 같은 속도로 전송된다. 이 때문에 패킷을 수신하는 목적지가 <code class=\"language-text\">R bit/sec</code> 의 속도로 <code class=\"language-text\">L bits</code>의 패킷을 송신한다면, 해당 패킷을 전송하는데 걸리는 시간은 <code class=\"language-text\">L/R</code> 이 된다.</li>\n</ul>\n<h3 id=\"store-and-forward-transmission저장-후-전달\" style=\"position:relative;\"><a href=\"#store-and-forward-transmission%EC%A0%80%EC%9E%A5-%ED%9B%84-%EC%A0%84%EB%8B%AC\" aria-label=\"store and forward transmission저장 후 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Store-and-Forward Transmission(저장-후-전달)</h3>\n<ul>\n<li>대부분의 패킷 스위치에서 사용하는 방식이다.</li>\n<li>스위치가 패킷의 첫 비트를 링크로 전송하기 전에 해당 패킷의 비트를 모두 다 가지고 있어야 한다.</li>\n<li>따라서 만약 어떤 두 end system 사이에 하나의 패킷 스위치가 있고, 링크의 전송속도가 R bit/sec 이며, L 비트로 이루어진 3개의 패킷이 있다면, 스위치에 패킷이 전달되는 시간은 L/R 이 될 것이다. 그리고 첫 패킷이 완전히 도착한 시점부터는 스위치가 목적지로 패킷을 보내기 시작하기 때문에, 전체 지연 시간은 <code class=\"language-text\">첫 패킷을 저장하는 시간 L/R + 목적지로 보내는 시간 L/R = 2L/R</code>이 된다.</li>\n<li>위와 같은 상황에서 3개의 패킷이 모두 전달되는 데에 걸리는 시간을 계산해보면, 첫 패킷이 목적지에 전달되기 까지는 2L/R의 시간이 걸리지만, 스위치에서 목적지로 패킷이 전달되는 동안 소스에서 스위치로 두번째 패킷이 동시에 전달되기 때문에 두번째 패킷부터 는 L/R의 지연시간으로 패킷을 전달할 수 있게된다. 따라서 전체 지연시간은 <code class=\"language-text\">첫번째 패킷의 지연시간 2L/R + 두번째 패킷의 지연시간 L/R + 세번째 패킷의 지연시간 L/R = 4L/R</code> 이 된다.</li>\n<li>정리해보면, end system 간 패킷 전달에 사용되는 지연시간은 다음과 같이 표현할 수 있다: <code class=\"language-text\">링크의 개수 X L/R</code></li>\n</ul>\n<h3 id=\"queing-delay-and-packet-loss큐잉-지연과-패킷-손실\" style=\"position:relative;\"><a href=\"#queing-delay-and-packet-loss%ED%81%90%EC%9E%89-%EC%A7%80%EC%97%B0%EA%B3%BC-%ED%8C%A8%ED%82%B7-%EC%86%90%EC%8B%A4\" aria-label=\"queing delay and packet loss큐잉 지연과 패킷 손실 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queing Delay and Packet Loss(큐잉 지연과 패킷 손실)</h3>\n<ul>\n<li>앞서 본 것 처럼 스위치는 패킷을 전달받아서 목적지로 보내주는 역할을 해야하는데, 스위치에 많은 패킷들이 몰릴 경우에 스위치는 이 패킷들을 무한히 받아들일 수는 없다. 이렇게 사용 가능한 리소스 이상의 패킷이 들어오는 경우를 <code class=\"language-text\">conjestion</code> 이라고 한다.</li>\n<li>따라서 스위치는 <code class=\"language-text\">출력 버퍼</code>라는 대기열을 만들어두고 현재 어떤 패킷을 전송중이라면, 새로 들어온 패킷을 <code class=\"language-text\">버퍼</code>에 넣어 대기시킨다. 이때 큐에서 패킷이 대기하면서 발생하는 지연시간을 Queing Delay(큐잉 지연)이라고 한다.</li>\n<li>만약 출력버퍼가 가득 차서 더 이상 새로운 패킷을 스위치에 대기시킬 수 없는 상황을 <code class=\"language-text\">packet loss</code> 라고 한다. 이때는 방금 들어온 새로운 패킷이나 대기열에서 대기중이던 패킷을 하나 지워주어야 한다.</li>\n</ul>\n<h3 id=\"forwarding-table-and-routing-protocol전달-테이블과-라우팅-프로토콜\" style=\"position:relative;\"><a href=\"#forwarding-table-and-routing-protocol%EC%A0%84%EB%8B%AC-%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\" aria-label=\"forwarding table and routing protocol전달 테이블과 라우팅 프로토콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Forwarding Table and Routing Protocol(전달 테이블과 라우팅 프로토콜)</h3>\n<ul>\n<li>라우터에 들어온 패킷을 다른 링크로 전달하려고 할 때, 라우터는 해당 패킷의 목적지가 어디인지 알고 있어야 어느 링크로 전달할지를 판단할 수 있다. 이렇게 목적지를 결정하는 것을 <code class=\"language-text\">routing</code> 이라고 한다.</li>\n<li>이를 위해서 각 패킷들은 <code class=\"language-text\">header</code>에 목적지 정보를 포함하고 있는데, 이 정보는 우리가 잘 알고있는 <code class=\"language-text\">IP 주소</code> 이다.</li>\n<li>라우터는 이 header 정보와 목적지 주소를 맵핑하는 Forwarding Table(전달 테이블)을 가진다. 이 전달 테이블에 따라 다음 라우터로 패킷을 전달하는 과정을 <code class=\"language-text\">forwarding</code>이라고 한다.</li>\n<li>뒤에서 더 자세히 다루겠지만, 이 전달 테이블은 라우팅 프로토콜을 통해 자동적으로 만들어지고, 항상 데이터를 전달할 수 있는 최단 거리를 가지려고 노력하게 된다.</li>\n</ul>\n<h3 id=\"datagram-networks\" style=\"position:relative;\"><a href=\"#datagram-networks\" aria-label=\"datagram networks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Datagram Networks</h3>\n<ul>\n<li>데이터그램 네트워크는 <code class=\"language-text\">stateless switch</code> 방식의 패킷 스위칭이다. stateless switch 방식은 스위치(라우터) 내에서 상태를 가지는지에 따라 결정된다.</li>\n<li>각 패킷은 라우팅 테이블에 따라 <code class=\"language-text\">독립적으로 전달</code>되고 이 때문에 각 패킷은 목적지 주소에 대한 정보를 항상 가지고 있어야한다. 여기서 독립적으로 전달된다는 것의 의미는 각 패킷이 목적지 주소가 같다고 해서 반드시 같은 경로로 이동할 필요가 없다는 것이다. 라우팅 테이블은 주기적으로 최단거리를 파악해서 테이블을 업데이트하기 때문에 경로는 언제든지 달라질 수 있다.</li>\n<li>경로가 달라진다는 것은 또 패킷이 목적지에 도착하는 순서 또한 달라질 수 있다는 것을 의미한다.</li>\n<li>데이터그램 네트워크는 <code class=\"language-text\">Connectionless Model</code> 이라고 부르기도 한다.</li>\n</ul>\n<h3 id=\"virtual-circuit-networks\" style=\"position:relative;\"><a href=\"#virtual-circuit-networks\" aria-label=\"virtual circuit networks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual Circuit Networks</h3>\n<ul>\n<li>Virtual Circuit Networks는 데이터가 전송되기 전에 송신자와 목적지 사이에 가상의 연결을 설정한다.</li>\n<li>따라서 circuit switching 처럼 자원을 예약할 수 있지만 해당 자원을 완전하게 보장받지는 못한다.</li>\n<li>Circuit Switching 처럼 빠른 패킷교환과 QoS 가 가능하지만 동시에 회선교환의 단점처럼 연결을 설정하기 위해 생기는 지연시간이 발생한다.</li>\n</ul>\n<h3 id=\"circuit-switching-회선-교환\" style=\"position:relative;\"><a href=\"#circuit-switching-%ED%9A%8C%EC%84%A0-%EA%B5%90%ED%99%98\" aria-label=\"circuit switching 회선 교환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Circuit Switching (회선 교환)</h3>\n<ul>\n<li>Circuit Switching 방식은 end system 간의 통신에 필요한 모든 자원을 미리 예약한다. 이렇게 미리 자원을 요청해 예약해서 사용하는 방식을 <code class=\"language-text\">예약(Reserve)</code> 방식이라고 한다.</li>\n<li>어떤 정보가 전달되기 전에 송신자와 수신자 간에는 연결(circuit)이 먼저 설정되어야 한다. 그리고 동시에 송수진자 사이에 일정한 <code class=\"language-text\">전송률(transmission rate)</code>를 예약한다. 따라서 송신자와 수신자는 <code class=\"language-text\">보장된 속도로 데이터를 주고받을 수 있게된다.</code></li>\n<li>Circuit Switching 에서 링크 내의 한 회선은 <code class=\"language-text\">Frequency-Division Multiplexing(FDM)</code> 혹은 <code class=\"language-text\">Time-Division Multiplexing(TDM)</code> 방식으로 구현된다.</li>\n</ul>\n<h4 id=\"frequency-division-multiplexingfdm\" style=\"position:relative;\"><a href=\"#frequency-division-multiplexingfdm\" aria-label=\"frequency division multiplexingfdm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Frequency-Division Multiplexing(FDM)</h4>\n<ul>\n<li>FDM 방식은 주파수 대역을 나누어서 한 채널에 여러 정보들을 담아 전달할 수 있게 한다.</li>\n<li><code class=\"language-text\">Link layer Switch</code>에서 전화선을 통해 전달된 정보들의 주파수 대역을 서로 겹치지 않게 설정하고 해당 정보들을 합쳐서 링크로 보낸다.</li>\n</ul>\n<h4 id=\"time-division-multiplexingtdm\" style=\"position:relative;\"><a href=\"#time-division-multiplexingtdm\" aria-label=\"time division multiplexingtdm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Time-Division Multiplexing(TDM)</h4>\n<ul>\n<li>동일한 대역폭 하나를 시간 슬롯으로 나눠서 채널에 할당한다.</li>\n</ul>\n<h2 id=\"packet-switching-vs-circuit-switching\" style=\"position:relative;\"><a href=\"#packet-switching-vs-circuit-switching\" aria-label=\"packet switching vs circuit switching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Packet Switching vs. Circuit Switching</h2>\n<ul>\n<li>패킷 교환은 회선 교환과는 다르게 예약을 하지 않고 필요할 때만 자원을 사용하기 때문에 처리할 수 있는 데이터의 양이 훨썬 더 많다.</li>\n<li>반면에 회선교환은 정보교환에 사용되는 자원들이 모두 예약되어야 하기 때문에 자원을 최대로 활용할 수 있고 QoS(Quality of Service) 가 보장된다는 장점이 있다.</li>\n</ul>","frontmatter":{"title":"[네트워크] 네트워크 코어(Network Core)","date":"September 15, 2020"}}},"pageContext":{"slug":"/Computer-Network/2020-09-15-네트워크-네트워크코어/","previous":{"fields":{"slug":"/CSS/css-치트시트/"},"frontmatter":{"title":"[한페이지로 끝내는 CSS] CSS 치팅시트","category":"CSS","draft":false}},"next":{"fields":{"slug":"/Computer-Network/2020-09-15-네트워크-기본 용어들과 접속 네트워크/"},"frontmatter":{"title":"[네트워크] 기본 용어들과 접속 네트워크(Basic Terms and Access Network)","category":"Computer-Network","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}