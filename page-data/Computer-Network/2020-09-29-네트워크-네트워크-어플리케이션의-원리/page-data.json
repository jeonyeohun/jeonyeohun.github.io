{"componentChunkName":"component---src-templates-blog-post-js","path":"/Computer-Network/2020-09-29-네트워크-네트워크-어플리케이션의-원리/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"dc91f883-1694-50e4-aaaa-23bca0c956b8","excerpt":"참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음 네트워크 어플리케이션 구조 네트워크 어플리케이션의 구조는 어플리케이션 개발자에 의해서 이 어플리케이션이 여러 end system…","html":"<p><em><strong>참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음</strong></em></p>\n<h2 id=\"네트워크-어플리케이션-구조\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"네트워크 어플리케이션 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 어플리케이션 구조</h2>\n<p>네트워크 어플리케이션의 구조는 어플리케이션 개발자에 의해서 이 어플리케이션이 여러 end system에서 어떻게 구성되어야 하는지에 대해 담고있다. 일반적으로 <code class=\"language-text\">클라이언트-서버 구조</code> 와 <code class=\"language-text\">P2P 구조</code>를 사용한다.</p>\n<h3 id=\"클라이언트-서버-구조\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%A1%B0\" aria-label=\"클라이언트 서버 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클라이언트-서버 구조</h3>\n<ul>\n<li><code class=\"language-text\">서버</code>: 항상 켜져있는 호스트</li>\n<li><code class=\"language-text\">클라이언트</code>: 서버에 요청을 보내는 호스트</li>\n<li>웹서비스에서 가장 흔히 사용되는 구조</li>\n<li>클라이언트가 서버에 객체를 요청하면, 서버는 객체를 보내서 응답한다. 따라서 <code class=\"language-text\">클라이언트끼리는 통신하지 않고</code> 항상 서버를 거쳐 통신하게 된다.</li>\n<li>서버는 지속해서 요청을 받아야하기 때문에 <code class=\"language-text\">고정 IP 주소</code>를 사용한다.</li>\n<li>서버에 많은 요청이 들어오면 요청을 처리하기가 어렵기 때문에 일반적으로 서버는 하나의 호스트가 아니라 여러 호스트로 하나의 서버를 구성한다. 이런 서버를 <code class=\"language-text\">데이터 센터</code> 라고 한다.</li>\n</ul>\n<h3 id=\"p2p-구조\" style=\"position:relative;\"><a href=\"#p2p-%EA%B5%AC%EC%A1%B0\" aria-label=\"p2p 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>P2P 구조</h3>\n<ul>\n<li>서버를 최소한으로 사용하거나 완전히 사용하지 않는다.</li>\n<li>한 호스트가 클라이언트와 서버의 역할을 동시에 한다. 이렇게 통신하는 호스트들을 <code class=\"language-text\">피어(peer)</code>라고 한다.</li>\n<li><code class=\"language-text\">자가확장성(self-scalability)</code>를 가지고 있다. 자가 확장성이란 피어가 파일을 다른 피어들에게 분배해서 서비스 능력을 향상시키는 것을 의미한다.</li>\n<li>고정적인 연결이 필요없기 때문에 유동적인 IP 주소가 사용된다.</li>\n<li>서버를 필요로하지 않고 큰 대역폭이 요구되지 않기 떄문에 비용이 매우 절감된다.</li>\n<li>분산된 구조때문에 보안, 성능, 신뢰성 문제가 해결과제로 남아있다.</li>\n</ul>\n<h2 id=\"프로세스-간-통신\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0\" aria-label=\"프로세스 간 통신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 간 통신</h2>\n<p>네트워크 통신을 수행하는 것은 호스트이지만 엄밀히 따져보면 호스트에서 실행되고 있는 프로세스라는 표현이 더 맞을 것이다. 그리고 통신을 하는 두 프로로세스는 메세지 교환 방식으로 서로 통신한다.</p>\n<h3 id=\"클라이언트와-서버-프로세스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%99%80-%EC%84%9C%EB%B2%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"클라이언트와 서버 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클라이언트와 서버 프로세스</h3>\n<ul>\n<li>두 프로세스 간의 통신 세션에서 통신을 초기화 하는 프로세스를 <code class=\"language-text\">클라이언트</code> 라고 하고 세션을 시작하기 위해 접속을 기다리는 프로세스를 <code class=\"language-text\">서버</code> 라고 한다.</li>\n<li>P2P 구조에서는 한 프로세스가 클라이언트 역할을 하기도 하고, 서버 역할을 하기도 한다.</li>\n</ul>\n<h3 id=\"프로세스와-컴퓨터-네트워크-사이의-인터페이스\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"프로세스와 컴퓨터 네트워크 사이의 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스와 컴퓨터 네트워크 사이의 인터페이스</h3>\n<ul>\n<li>두 프로세스는 메세지를 주고받는 방식으로 통신다.</li>\n<li>메세지를 주고받기 위해서는 <code class=\"language-text\">소켓(socket)</code>을 이용한다.</li>\n<li>프로세스는 송신하고자 하는 메세지를 소켓에 보내고, 소켓은 이 메세지를 네트워크로 밀어넣어 송신을 시작한다. 그리고 메세지가 수신될 때에는 메세지가 소켓을 거쳐 송신 프로세스에 도달하게 된다.</li>\n<li>즉 소켓은 어플리케이션과 네트워크 사이의 인터페이스 역할을 하게되고, <code class=\"language-text\">API(Application Programming Interface)</code> 라고 부를 수 있다.</li>\n</ul>\n<h3 id=\"프로세스-주소-배정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A3%BC%EC%86%8C-%EB%B0%B0%EC%A0%95\" aria-label=\"프로세스 주소 배정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 주소 배정</h3>\n<ul>\n<li>메세지가 전달되기 위해서는 목적지에 대한 주소정보가 필요하다. 그리고 우리는 통신이 호스트 자체가 아닌 프로세스 사이에 일어난다고 정리했기 때문에, 목적지 호스트 내부에 어떤 프로세스로 메세지를 전달해야하는지에 대한 ㅈ어보도 필요할 것이다.</li>\n<li>따라서 인터넷에서는 호스트를 <code class=\"language-text\">IP 주소</code>로 식별하고, 호스트 내에 수신 프로세스를 식별하기 위해 <code class=\"language-text\">포트</code>를 사용한다.</li>\n<li>자주 사용되는 어플리케이션들은 대표적인 포트 번호를 할당받게 되는데, 웹서버에 사용되는 포트 번호는 일반적으로 <code class=\"language-text\">80번</code> 이고, 이런 포트번호를 <code class=\"language-text\">well-known</code> 포트 번호라고 한다.</li>\n</ul>\n<h2 id=\"어플리케이션에서-사용하는-트랜스포트-서비스\" style=\"position:relative;\"><a href=\"#%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8F%AC%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\"어플리케이션에서 사용하는 트랜스포트 서비스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어플리케이션에서 사용하는 트랜스포트 서비스</h2>\n<p>어플리케이션에서 소켓을 거쳐 트랜스포트 계층에 도달한 메세지는 네트워크를 통해 해당 메세지를 목적지로 이동시켜야 한다. 트랜스포트 계층은 메세지 전달을 위해서 다양한 트랜스포트 프로토콜 중 하나를 선택해서 사용하게 된다. 이 트랜스포트 서비스가 제공해야할 서비스들은 다음과 같은 기준으로 분류할 수 있다.</p>\n<h3 id=\"신뢰적-데이터-전송\" style=\"position:relative;\"><a href=\"#%EC%8B%A0%EB%A2%B0%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1\" aria-label=\"신뢰적 데이터 전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>신뢰적 데이터 전송</h3>\n<ul>\n<li>프로토콜이 보장된 데이터 전송을 제공한다면, <code class=\"language-text\">신뢰적 데이터 전송(Reliable Data Transfer)</code>을 제공한다고 할 수 있다.</li>\n<li>신뢰적 데이터 전송을 제공하는 프로토콜은 packet loss 없이 데이터가 목적지로 도착할 수 있게 한다.</li>\n<li><code class=\"language-text\">손실 허용 어플이케이션(Loss-tolerant Application)</code> 은 어느정도의 데이터 손실이 발생하더라도 데이터를 전송할 수 있게 한다.</li>\n</ul>\n<h3 id=\"처리량\" style=\"position:relative;\"><a href=\"#%EC%B2%98%EB%A6%AC%EB%9F%89\" aria-label=\"처리량 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>처리량</h3>\n<ul>\n<li><code class=\"language-text\">Throughput(처리량)</code>은 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율을 나타낸다.</li>\n<li>처리율을 반드시 지켜야 하는 어플리케이션들을 <code class=\"language-text\">대역폭 민감 어플리케이션(Bandwidth-sensitive Application)</code> 이라고 한다. 예를 들어 인터넷 전화와 같은 어플리케이션들은 일정한 처리량으로 음성을 인코딩하기 때문에 네트워크가 해당 처리량보다 낮은 처리량을 제공한다면 어플리케이션을 사용할 수 없을 것이다.</li>\n<li>반대로 <code class=\"language-text\">탄력적 어플리케이션(Elastic Application)</code>은 가용한 처리율을 모두 사용해서 데이터를 전송하게 된다. 예를 들어 파일 전송과 같은 경우에는 처리량에 상관없이 현재 속도를 모두 사용하면서 데이터를 송수신하게 된다.</li>\n</ul>\n<h3 id=\"시간\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84\" aria-label=\"시간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간</h3>\n<ul>\n<li>트랜스포트 계층 프로토콜은 <code class=\"language-text\">시간 보장(timing quarantee)</code>을 제공하기도 한다.</li>\n<li>시간이 보장되어야 하는 데이터들, 예를 들어 실시간으로 데이터가 송수신 되어야하는 상황에서는 일정 시간안에 주어진 데이터가 모두 수신자 소켓에 전달되어야 하는 요구사항을 충족해야한다.</li>\n</ul>\n<h2 id=\"인터넷-전송-프로토콜이-제공하는-서비스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%84%B7-%EC%A0%84%EC%86%A1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\"인터넷 전송 프로토콜이 제공하는 서비스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터넷 전송 프로토콜이 제공하는 서비스</h2>\n<h3 id=\"tcptransmission-control-protocol-서비스\" style=\"position:relative;\"><a href=\"#tcptransmission-control-protocol-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\"tcptransmission control protocol 서비스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP(Transmission Control Protocol) 서비스</h3>\n<ul>\n<li>TCP 서비스는 <code class=\"language-text\">연결지향형 서비스(Connection-oriented Service)</code> 를 제공한다. 연결지향형 서비스는 메세지가 전달되기 전에 클라이언트와 서버가 전송제어정보를 교환해서 연결을 미리 설정한다.</li>\n<li>이렇게 클라인언트와 서버가 전송제어정보를 주고 받는 과정을 <code class=\"language-text\">핸드셰이킹(Handshaking)</code> 이라고 한다.</li>\n<li>핸드셰이킹 이후에는 두 프로세스가 서로 TCP 연결을 설정하고 이 연결을 서로가 서로에게 메세지를 주고받을 수 있는 양방향 연결이 된다. 이런 양방향 연결을 <code class=\"language-text\">전이중(full-duplex)</code> 연결이라고 한다.</li>\n<li>TCP 서비스는 <code class=\"language-text\">Congestion Control</code> 을 제공한다. Congestion Control 은 네트워크가 처리할 수 있는 양 이상의 정보가 라우터에 들어오게 되면 sender 에게 메세지를 보내서 보내는 송신하는 데이터 전송량을 낮추게끔 한다.</li>\n<li>TCP 서비스는 <code class=\"language-text\">Flow Control</code> 역시도 제공하는데, Flow Control 은 end-to-end 사이에 수신버퍼의 overflow를 제한하는 방법인데, 송신측의 속도가 너무 빠를 경우에 송신 측의 데이터 전송량을 수신측에 맞추어 조절하는 기능을 한다.</li>\n<li>Congestion Control 과 Flow Control의 차이가 조금 헷갈리는데 간단하게 정리하자면, <code class=\"language-text\">Congestion Control 은 네트워크 라우터의 데이터 처리량이 송신측의 전송량을 모두 처리하기 어려운 상황</code>에서 송신측의 전송량을 줄이는 방법이고, <code class=\"language-text\">Flow Control 은 송신측의 전송량이 수신측의 데이터 처리 속도보다 빠른 상황</code>에서 송신측의 전송량을 줄이는 방법이다.</li>\n<li>TCP 서비스는 Timing 과 Bandwidth 에 대한 보장 서비스는 지원하지 않는다.</li>\n<li>TCP 서비스는 <code class=\"language-text\">신뢰적 데이터 전송 서비스(Reliable Transport)</code> 를 제공한다. 신회적 데이터 전송 서비스는 프로세스가 모든 데이터를 오류없이, 그리고 올바른 순서대로 전달하는 것을 보장한다.</li>\n</ul>\n<h4 id=\"sslsecure-socket-layer\" style=\"position:relative;\"><a href=\"#sslsecure-socket-layer\" aria-label=\"sslsecure socket layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL(Secure Socket Layer)</h4>\n<ul>\n<li>TCP 서비스를 강화한 형태로 프로세스간의 통신에 보안서비스를 제공한다.</li>\n<li>송신서비스가 보내는 데이터가 SSL 소켓에 전달되고, SSL 소켓은 데이터를 암호화한다.</li>\n<li>암호화된 데이터는 송신 프로세스의 TCP 소켓에 전달되고 TCP 소켓은 기존의 TCP 서비스 처럼 연결을 설정하고 데이터를 전달한다.</li>\n<li>수신 프로세스의 TCP 소켓은 데이터를 전달 받은 뒤에 해당 데이터를 수신 프로세스의 SSL 소켓에 보낸다.</li>\n<li>수신 프로세스의 SSL 소켓은 암호화된 데이터를 해석하고 수신 프로세스에 암호가 풀린 일반 데이터를 전달한다.</li>\n</ul>\n<h3 id=\"udpuser-datagram-protocol-서비스\" style=\"position:relative;\"><a href=\"#udpuser-datagram-protocol-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\"udpuser datagram protocol 서비스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP(User Datagram Protocol) 서비스</h3>\n<ul>\n<li>UDP 서비스는 비연결형 서비스이다. 따라서 통신전에 두 프로세스가 핸드셰이킹을 하는 과정을 가지지 않는다.</li>\n<li>UDP 서비스는 신뢰적인 데이터 전송서비스를 제공하지 않는다. 따라서 송신 프로세스가 보내는 메세지가 수신 프로세스에 반드시 전달된다는 보장이 없고 수신 프로세스의 도착하는 메세지의 순서가 송신측에서 보내는 순서와 다르게 도착할 수도 있다.</li>\n</ul>","frontmatter":{"title":"[네트워크] 네트워크 어플리케이션의 원리","date":"September 30, 2020"}}},"pageContext":{"slug":"/Computer-Network/2020-09-29-네트워크-네트워크-어플리케이션의-원리/","previous":{"fields":{"slug":"/Computer-Network/2020-09-30-네트워크-웹과-HTTP/"},"frontmatter":{"title":"[네트워크] 웹과 HTTP","category":"Computer-Network","draft":false}},"next":{"fields":{"slug":"/Computer-Network/2020-10-02-네트워크-P2P/"},"frontmatter":{"title":"[네트워크] P2P","category":"Computer-Network","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}