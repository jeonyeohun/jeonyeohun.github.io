{"componentChunkName":"component---src-templates-blog-post-js","path":"/Computer-Network/2020-10-01-네트워크-DNS/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"f7b9c441-3cce-5400-88af-aa935b16de8f","excerpt":"참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음 호스트를 식별하는 방법 패킷을 전달하거나 어떤 서버로 접속할 떄, 우리는 해당 호스트가 누구인지 식별할 수 있는 수단이 필요하다. 그래서 우리는 www.example.com 과 같은 을 사용한다. 하지만 호스트 이름은 가변 문자이기 때문에 라우터가 처리하기에는 어려움이 있다. 그래서 4바이트로 구성된 127.0.0.…","html":"<p><em><strong>참고도서: 컴퓨터 네트워킹 : 하향식 접근. 7판. James F. Kurose , Keith W.Ross 지음</strong></em></p>\n<h2 id=\"호스트를-식별하는-방법\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%8B%9D%EB%B3%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"호스트를 식별하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호스트를 식별하는 방법</h2>\n<ul>\n<li>패킷을 전달하거나 어떤 서버로 접속할 떄, 우리는 해당 호스트가 누구인지 식별할 수 있는 수단이 필요하다.</li>\n<li>그래서 우리는 www.example.com 과 같은 <code class=\"language-text\">호스트 이름(Host Name)</code>을 사용한다.</li>\n<li>하지만 호스트 이름은 가변 문자이기 때문에 라우터가 처리하기에는 어려움이 있다. 그래서 4바이트로 구성된 127.0.0.1 과 같은 <code class=\"language-text\">IP 주소</code> 를 컴퓨터 내부에서는 사용한다.</li>\n<li>사람은 호스트 이름을 선호하지만 라우터는 IP주소를 선호하기 때문에, 호스트 이름을 IP 주소로 변환하는 기술인 <code class=\"language-text\">DNS(Domain Name System)</code> 가 고안되어 사용되고 있다.</li>\n</ul>\n<h2 id=\"dnsdomain-name-system\" style=\"position:relative;\"><a href=\"#dnsdomain-name-system\" aria-label=\"dnsdomain name system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS(Domain Name System)</h2>\n<ul>\n<li>DNS는 DNS 서버들이 계층 구조로 나뉘어져 구성되는 <code class=\"language-text\">분산 데이터베이스</code> 임과 동시에 호스트에게 이 데이터베이스 정보를 제공하는 <code class=\"language-text\">어플리케이션 계층 프로토콜</code>이기도 하다.</li>\n<li>DNS는 프로토콜은 <code class=\"language-text\">UDP</code> 를 사용하여 수행되고 포트번호는 <code class=\"language-text\">53번</code> 을 사용한다.</li>\n<li>\n<p>어떤 사용자가 www.example.com에 접속을 시도한다고 가정해보자. 이떄 DNS 프로토콜은 다음과 같은 과정을 거친다.</p>\n<ol>\n<li>사용자가 입력한 주소(호스트 이름)이 브라우저에서 추출되어서 DNS 의 클라이언트에 전달된다.</li>\n<li>DNS 클라이언트는 DNS 서버로 호스트 이름을 보내서 IP주소를 요청한다.</li>\n<li>DNS 클라이언트는 IP주소를 받은 뒤 브라우저에게 해당 주소를 전달한다.</li>\n<li>브라우저는 전달받은 IP 주소와 해당 주소의 80번 포트에 HTTP 프로토콜을 이용해 TCP 연결을 수행한다.</li>\n</ol>\n</li>\n<li>\n<p>DNS 는 여러 다른 서비스들도 제공한다.</p>\n<ul>\n<li><code class=\"language-text\">호스트 앨리어싱(Host Aliacing)</code> : 복잡한 호스트 이름을 가진 호스트가 별명을 통해 단축된 호스트 이름을 가질 수 있게 한다. 여기서 진짜 호스트 이름을 <code class=\"language-text\">정식 호스트 이름 (canonical hostname)</code> 이라고 한다. DNS 는 이렇게 별칭으로 입력된 호스트 이름에 대해서 정식 호스트 이름을 얻을 수 있게 하는 기능을 수행한다.</li>\n<li><code class=\"language-text\">메일 서버 앨리어싱(Mail Server Aliacing)</code> : 일반 호스트 이름과 마찬가지로 메일 서버의 호스트 역시 별칭을 통해 더 간단하고 기억하기 쉬운 호스트 이름을 가질 수 있도록 한다.</li>\n<li><code class=\"language-text\">부하 분산(Load Distribution)</code> : 중복 서버 사이에 걸리는 부하를 분산시키기 위해 사용된다. 여러 IP주소가 하나의 정식 호스트 이름과 연결된 경우에, 한번에 많은 연결이 요청되더라도 DNS는 순환식으로 응답을 보내기 때문에 트래픽 부하가 분산되는 효과가 있다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"dns-동작원리\" style=\"position:relative;\"><a href=\"#dns-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"dns 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS 동작원리</h2>\n<h3 id=\"분산-계층-데이터베이스\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EC%82%B0-%EA%B3%84%EC%B8%B5-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4\" aria-label=\"분산 계층 데이터베이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분산 계층 데이터베이스</h3>\n<ul>\n<li>DNS 서버는 확정성을 위해 DNS 서버를 여러 계층으로 나누어서 서버를 분산한다. DNS 서버는 총 세 유형의 계층 서버들로 구성되는데, <code class=\"language-text\">루트 DNS 서버</code>, <code class=\"language-text\">최상위 레벨 도메인 네임 DNS 서버(TLD)</code>, 그리고 <code class=\"language-text\">책임 DNS 서버</code>로 이루어져 있다.</li>\n<li><code class=\"language-text\">루트 DNS 서버</code> : 클라이언트가 호스트 이름을 입력하고 접속을 시도할 때, 우선적으로 호스트 이름이 루트 DNS 서버로 전달된다. 루트 DNS 서버는 전 세계에 400개 이상이 존재하고 13개의 기관에서 나누어서 관리하고 있다. 루트 DNS서버는 전달된 호스트 이름을 확인하고 그에 맞는 TLD 서버의 IP를 다시 전달한다.</li>\n<li><code class=\"language-text\">최상위 레벨 도메인(TLD) 서버</code> : <code class=\"language-text\">.com</code>, <code class=\"language-text\">.org</code>, <code class=\"language-text\">.net</code> 과 같은 상위 레벨 도메인이 각각 TLD 서버에서 관리된다. TLD 서버로 전달된 호스트 이름은 이름에 맞는 책임 DNS 서버의 IP 주소가 되어 전달된다.</li>\n<li><code class=\"language-text\">책임 DNS 서버</code> : 책임 DNS 서버는 각 호스트 이름에 대한 IP 주소를 맵핑해서 가지고 있다.</li>\n<li>DNS는 위 서버를 요청 호스트와 직접적으로 통신하는 것으로 동작하지 않고 요청 호스트와 DNS 계층 서버 사이에 <code class=\"language-text\">로컬 DNS 서버</code> 를 두어 요청과 응답을 주고받는다.</li>\n</ul>\n<h3 id=\"동작-과정\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작 과정</h3>\n<ul>\n<li>\n<p>실제로 어떤 호스트 이름을 사용자가 입력하면 분산 계층에 따라 다음과 같은 과정으로 진행된다.</p>\n<ol>\n<li>요청 호스트가 <code class=\"language-text\">로컬 DNS 서버</code>에 호스트 이름을 보낸다.</li>\n<li>로컬 DNS 서버는 <code class=\"language-text\">루트 DNS 서버</code>에 요청메세지를 전달한다. 루트 DNS 서버는 전달된 호스트 이름에 대한 책임을 가진 TLD 서버의 IP 주소리스트를 로컬 DNS 서버로 보낸다.</li>\n<li>로컬 DNS 서버는 응답받은 <code class=\"language-text\">TLD 서버</code>로 DNS 요청 메세지를 다시 보낸다. TLD 서버는 전달받은 호스트 이름에 대한 책임을 가진 책임 DNS 서버의 IP 주소를 로컬 DNS 서버로 보낸다.</li>\n<li>로컬 DNS 서버는 응답반은 <code class=\"language-text\">책임 DNS 서버</code>로 DNS 요청 메세지를 보낸다. 이제 책임 DNS 서버는 전달받은 호스트 이름에 대한 모든 맵핑결과를 로컬 DNS 서버로 전달한다.</li>\n<li>로컬 DNS 서버는 응답받은 결과를 요청 호스트에게 응답메세지로 보낸다.</li>\n</ol>\n</li>\n<li>DNS 가 동작하는 과정은 <code class=\"language-text\">재귀적 질의(recursive query)</code> 와 <code class=\"language-text\">반복적 질의(iterative query)</code> 로 나뉘는데, 위처럼 각 계층 서버들이 로컬 DNS 서버와 질의/응답을 주고받으며 IP 주소를 받아오는 과정을 반복적 질의라 하고, 재귀적 질의는 각 계층 서버가 로컬 DNS 서버를 거치지 않고 직접적으로 자신의 하위 계층 서버에게 요청을 보내 응답을 받는 구조를 의미한다. 즉, 재귀적 질의에서는 <code class=\"language-text\">요청 호스트-&gt;로컬 DNS 서버-&gt;루트 DNS 서버-&gt;TLD DNS 서버-&gt;책임 DNS 서버</code> 순으로 요청메세지를 보내게 된다.</li>\n</ul>\n<h3 id=\"dns-캐싱\" style=\"position:relative;\"><a href=\"#dns-%EC%BA%90%EC%8B%B1\" aria-label=\"dns 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS 캐싱</h3>\n<ul>\n<li>웹캐싱과 같은 개념으로 DNS도 이전에 가져왔던 IP 주소에 대한 정보를 미리 저장해둠으로 DNS 캐싱을 구현할 수 있다.</li>\n<li>로컬 DNS 서버가 IP 주소를 미리 보관해두고 요청 호스트에서 자신이 가지고 있는 호스트에 대한 IP 주소정보를 요청했을 때, DNS 계층 서버들을 방문할 필요없이 바로 IP주소를 제공할 수 있게 한다.</li>\n</ul>\n<h2 id=\"dns-레코드\" style=\"position:relative;\"><a href=\"#dns-%EB%A0%88%EC%BD%94%EB%93%9C\" aria-label=\"dns 레코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS 레코드</h2>\n<ul>\n<li>각 계층의 DNS서버는 <code class=\"language-text\">자원 레코드(Resource Record, RR)</code>를 통해 호스트 이름과 IP주소를 맵핑한다.</li>\n<li>자원 레코드는 <code class=\"language-text\">Name</code>, <code class=\"language-text\">Value</code>, <code class=\"language-text\">Type</code>, <code class=\"language-text\">TTL</code>의 네 개의 투플로 이루어져 있다.</li>\n<li>\n<p>여기서 <code class=\"language-text\">Type</code> 필드에 어떤 값이 들어가는지에 따라 <code class=\"language-text\">Name</code> 과 <code class=\"language-text\">Value</code> 의 값을 해석하는 방법이 달라진다.</p>\n<ul>\n<li><code class=\"language-text\">Type=A</code>의 경우에는 <code class=\"language-text\">Name 은 호스트 이름</code>, <code class=\"language-text\">Value는 해당 호스트에 대한 IP 주소</code>를 의미한다. (i.e. <code class=\"language-text\">(relay1.bar.foo.com, 145.37.42.126, A)</code>)</li>\n<li><code class=\"language-text\">Type=NS</code>의 경우에는 <code class=\"language-text\">Name은 도메인 이름</code>, <code class=\"language-text\">Value는 도메인 내부의 호스트에 대한 책임 DNS 서버의 호스트 이름</code> 을 의미한다. (i.e. <code class=\"language-text\">(foo.com, dns.foo.com, NS)</code>)</li>\n<li><code class=\"language-text\">Tyee=CNMAE</code>의 경우에는 <code class=\"language-text\">Name은 별칭 호스트 이름</code>, <code class=\"language-text\">Value는 정식 호스트 이름</code> 을 의미한다. (i.e. <code class=\"language-text\">(foo.com, relay.bar.foo.com, CNAME)</code>)</li>\n<li><code class=\"language-text\">Tyee=MX</code>의 경우에는 <code class=\"language-text\">Name은 메일 서버의 별칭 호스트 이름</code>, <code class=\"language-text\">Value는 정식 호스트 이름</code> 을 의미한다. (i.e. <code class=\"language-text\">(foo.com, mail.foo.com, MX)</code>)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"dns-메세지\" style=\"position:relative;\"><a href=\"#dns-%EB%A9%94%EC%84%B8%EC%A7%80\" aria-label=\"dns 메세지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS 메세지</h2>\n<ul>\n<li>DNS 의 질의와 응답(query and response)에 사용되는 DNS 메세지는 아래와 같은 필드들로 구성되어 있다.</li>\n<li>\n<p><code class=\"language-text\">헤더 영역</code> : 첫 12바이트를 차지하고 여러 개의 하위 필드를 포함한다.</p>\n<ul>\n<li><code class=\"language-text\">식별자</code> : 이 식별자를 통해 질의에 대한 수신과 응답을 맵핑시킨다.</li>\n<li><code class=\"language-text\">질의/응답 플래그</code> : 이 메세지가 <code class=\"language-text\">질의라면 0, 응답이라면 1</code>을 설정한다.</li>\n<li><code class=\"language-text\">책임 플래그</code> : DNS 서버가 질의 이름에 대한 책임 서버일 때 설정한다.</li>\n<li><code class=\"language-text\">재귀 요구 플래그</code> : DNS 서버가 레코드를 가지고 있지 않을 때 호스트 혹은 DNS 서버가 재귀적인 질의를 원한다면 설정된다.</li>\n<li><code class=\"language-text\">재귀 가능 필드</code> : DNS 서버가 재귀적 질의를 허용한다면 설정된다.</li>\n<li><code class=\"language-text\">개수 필드</code> : 질의의 수, 답변의 RR 수, 책임 RR의 수, 추가 RR의 수를 저장한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">질문 영역</code> : 현재 질의에 대한 정보를 담는다. 질의되는 이름과 질문의 타입이 저장된다.</li>\n<li><code class=\"language-text\">답변 영역</code> : 질의에 대한 자원 레코드(RR) 가 포함된다. 호스트 이름은 여러개의 IP 주소를 가질 수 있기 때문에 RR 역시 여러개가 응답될 수 있다.</li>\n<li><code class=\"language-text\">책임 영역</code> : 다른 책임 서버의 RR을 포함한다.</li>\n<li><code class=\"language-text\">추가 영역</code> : 추가적으로 도움이 될만한 RR을 포함한다. 예를들어, DNS 서버가 가진 호스트 이름이 별칭 호스트 이름이라면 TYPE-A 레코드를 가지고 있어 별칭 호스트에 대한 정식 이름과 IP 주소 정보를 포함하게 된다.</li>\n</ul>\n<h2 id=\"dns-데이터베이스\" style=\"position:relative;\"><a href=\"#dns-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4\" aria-label=\"dns 데이터베이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DNS 데이터베이스</h2>\n<ul>\n<li>DNS 가 분산형 데이터베이스라면, 어딘가에서 이 데이터베이스에 정보들을 넣어줘야 인터넷 사용자들이 데이터를 사용할 수 있을 것이다.</li>\n<li>도메인 이름은 특정한 등록기관들이 관리하게 되는데, 이런 관리 기관들 때문에 도메인이 중복되지 않고 유일성을 유지할 수 있다.</li>\n<li>이런 등록기관은 <code class=\"language-text\">ICANN(InternetCorporation for Assigned Names and Numbers)</code>에서 승인한다.</li>\n</ul>","frontmatter":{"title":"[네트워크] DNS","date":"October 01, 2020"}}},"pageContext":{"slug":"/Computer-Network/2020-10-01-네트워크-DNS/","previous":{"fields":{"slug":"/Computer-Network/2020-09-30-네트워크-전자메일/"},"frontmatter":{"title":"[네트워크] 인터넷 전자메일","category":"Computer-Network","draft":false}},"next":{"fields":{"slug":"/Computer-Network/2020-10-02-네트워크-P2P/"},"frontmatter":{"title":"[네트워크] P2P","category":"Computer-Network","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}