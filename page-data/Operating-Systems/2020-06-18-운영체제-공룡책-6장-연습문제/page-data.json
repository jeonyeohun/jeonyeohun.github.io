{"componentChunkName":"component---src-templates-blog-post-js","path":"/Operating-Systems/2020-06-18-운영체제-공룡책-6장-연습문제/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"75836354-2054-5225-bf4e-acd5f215e709","excerpt":"참고도서: Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne 6장 - 동기화 도구들 6.1 6.…","html":"<p>참고도서: <em>Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne</em></p>\n<h2 id=\"6장---동기화-도구들\" style=\"position:relative;\"><a href=\"#6%EC%9E%A5---%EB%8F%99%EA%B8%B0%ED%99%94-%EB%8F%84%EA%B5%AC%EB%93%A4\" aria-label=\"6장   동기화 도구들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6장 - 동기화 도구들</h2>\n<p><strong>6.1 6.4절에서 인터럽트를 자주 비활성화하면 시스템 클록에 영향을 줄 수 있다고 언급했다. 왜 이런 일이 발생할 수 있고 그러한 영향을 최소화할 수 있는 방법에 대해 설명하라</strong></p>\n<ul>\n<li>인터럽트를 비활성화 하게되면 한 프로세스가 공유자원을 사용하고 있을 때 다른 프로세스들의 접근을 막을 수는 있지만 그다지 효쥴적인 방법은 아니다. 특히 멀티프로세싱 시스템에서는 한 프로세스를 위해 다른 모든 프로세스의 인터럽트를 막게되면 프로세스의 전체 클럭사이클에 영향을 주게된다. 이 문제를 최소화할 수 있는 방법은 Test-and-Set이나 Compare-and-Swap 같은 원자적인 연산을 하게 만듦으로서 해결할 수 있다.</li>\n</ul>\n<hr>\n<p><strong>6.2 바쁜 대기라는 용어의 의미는 무엇인가? 운영체제에는 어떤 다른 대기가 있는가? 바쁜 대기를 완전히 피할 수 있는가?</strong></p>\n<ul>\n<li>바쁜 대기는 lock을 획득하지 못한 프로세스가 무한루프를 돌며 lock의 획득이 가능할 때까지 공회전 하고 있는 상태를 말한다. 실제로 아무 의미가 없는 연산이므로 임의의 대기 큐를 만들고 프로세스를 해당 큐에 넣은채로 block 시킨 뒤 lock에 대한 signal 함수가 포착되면 block을 풀고 다시 실행하도록 만들 수 있다.</li>\n</ul>\n<hr>\n<p><strong>6.3 스핀락이 단일 프로세서 시스템에 적합하지 않지만 다중 처리기 시스템에서는 종종 사용되는 이유를 설명하라</strong></p>\n<ul>\n<li>스핀락은 lock을 획득하지 못했을 때 프로세스를 대기상태나 준비상태로 만들지 않기 때문에 프로세스는 CPU를 계속 선점하면서도 별 다른 작업을 수행하지 않고 공회전하기 때문에 적합하지 않다. 하지만 멀티프로세서 시스템에서는 만약 스핀락의 기다리는 시간이 그리 길지 않다면, busy wating 을 하는 것이 context switching 을 통해 다른 프로세스로 전환되는 overhead 보다 더 좋을 수도 있다.</li>\n</ul>\n<hr>\n<p><strong>6.4 wait() 및 signal() 세마포 연산이 원자적으로 실행되지 않으면 상호 배제가 위반될 수 있음을 보여라</strong></p>\n<ul>\n<li>세마포의 wait 과 signal은 단순히 정수를 증감하는 연산을 수행한다. 따라서 이 연산이 원자적으로 수행되지 않는다면, 다수의 프로세스가 wait()이나 signal()을 호출 했을 때, 세마포의 정수값이 범위를 벗어나거나 의도하지 않은 값으로 변경될 여지가 있다.</li>\n</ul>\n<p><strong>6.5 이진 세마포를 사용하여 n개의 프로세스 간에 상호배제를 구현하는 방법을 설명하라</strong></p>\n<ul>\n<li>이진 세마포의 초기값을 1로 초기화하고 이진 세마포의 값이 0이 될 때만 임계구역의 접근을 허용한다면, n개의 프로세스가 lock을 획득하기 위해 wait() 을 할 때마다 첫 프로세스를 제외한 나머지 프로세스들에 의해 세마포의 값은 음수가 되고, lock을 획득한 프로세스가 임계구역을 나오면서 signal() 연산을 수행하게되면 세마포의 값이 0이 되므로 대기중이던 프로세스 중 하나가 임계구역에 새로 진입할 수 있게된다.</li>\n</ul>\n<hr>\n<p><strong>6.6 문제가 너무 길어서..</strong></p>\n<ul>\n<li>남편이 withdraw를 하고 있을 때, 동시에 아내가 withdraw를 하게되면 양쪽에서 모두 값을 빼내려고 하기 때문에 둘 중 한 명은, 혹은 둘 다 값을 받는데 실패할 수도 있다. 경쟁조건이 발생하지 않도록 하려면 두 연산은 mutual exclusion으로 만들어서 한번에 하나의 연산만 수행하도록 하면 경쟁 조건을 막을 수 있다.</li>\n</ul>","frontmatter":{"title":"[운영체제] 공룡책(Operating System Concepts) 연습문제 풀기: 6장","date":"June 18, 2020"}}},"pageContext":{"slug":"/Operating-Systems/2020-06-18-운영체제-공룡책-6장-연습문제/","previous":{"fields":{"slug":"/Operating-Systems/2020-06-18-운영체제-공룡책-5장-연습문제/"},"frontmatter":{"title":"[운영체제] 공룡책(Operating System Concepts) 연습문제 풀기: 5장","category":"Operating-Systems","draft":false}},"next":{"fields":{"slug":"/Operating-Systems/2020-06-18-운영체제-공룡책-9장-연습문제/"},"frontmatter":{"title":"[운영체제] 공룡책(Operating System Concepts) 연습문제 풀기: 9장","category":"Operating-Systems","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}