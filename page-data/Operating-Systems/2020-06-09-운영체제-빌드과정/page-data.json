{"componentChunkName":"component---src-templates-blog-post-js","path":"/Operating-Systems/2020-06-09-운영체제-빌드과정/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"97a7b1de-f381-5c6b-9b56-146131a618ae","excerpt":"참고도서: Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne 소스코드에서 응용프로그램이 되기까지… 우리가 작성한 소스코드는 한 번의 버튼이나 커맨드를 통해서 실행되곤 하지만 그 내부는 생각보다 복잡하다. 컴파일부터 실행파일이 되어 프로세스로 메모리에 적재되기까지 소스코드가 변화되는 과정을 알아보자. Preprocessing…","html":"<p>참고도서: <em>Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne</em></p>\n<h2 id=\"소스코드에서-응용프로그램이-되기까지\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EC%9D%91%EC%9A%A9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EB%90%98%EA%B8%B0%EA%B9%8C%EC%A7%80\" aria-label=\"소스코드에서 응용프로그램이 되기까지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소스코드에서 응용프로그램이 되기까지…</h2>\n<p>우리가 작성한 소스코드는 한 번의 버튼이나 커맨드를 통해서 실행되곤 하지만 그 내부는 생각보다 복잡하다. 컴파일부터 실행파일이 되어 프로세스로 메모리에 적재되기까지 소스코드가 변화되는 과정을 알아보자.</p>\n<h3 id=\"preprocessing-소스코드에서-새로운-소스코드로\" style=\"position:relative;\"><a href=\"#preprocessing-%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EB%A1%9C\" aria-label=\"preprocessing 소스코드에서 새로운 소스코드로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Preprocessing: 소스코드에서 새로운 소스코드로</h3>\n<p>컴파일러를 통해 소스코드를 컴파일하게 되면 가장 처음 일어나는 작업이 주어진 소스코드를 새로운 소스코드로 번역하는 작업이다. 여기서 <code class=\"language-text\">새로운 소드코드</code>는 우리가 import 하거나 include 한 외부의 라이브러리들, 매크로 등, 기존의 소스코드를 대체하는 코드들이 모두 합쳐진 코드를 말한다. 예를 들어, C언어의 <code class=\"language-text\">printf()</code> 함수는 우리가 직접 정의한 것이 아니라 stdio.h 헤더 파일안에 정의되어 있다. 그리고 이 헤더안에 정의된 코드들이 소스코드를 변환화는 과정에서 기존 소스코드를 대체하게 된다.</p>\n<h3 id=\"compilation-소스코드를-오브젝트-파일로\" style=\"position:relative;\"><a href=\"#compilation-%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%ED%8C%8C%EC%9D%BC%EB%A1%9C\" aria-label=\"compilation 소스코드를 오브젝트 파일로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compilation: 소스코드를 오브젝트 파일로</h3>\n<p>우리가 잘 아는 컴파일 과정을 거치면 소스코드가 바이너리코드와 데이터로 해석되어 오브젝트 파일이 된다. 컴파일러는 가장 먼저 소스코드를 어셈블리 언어로 이루어진 명령어들로 해독하고 이 명령어들이 다시 이진 코드로 해석해서 오브젝트 파일을 생성하게 된다. 컴파일 단계에서 가장 먼저 생성되는 오브젝트 파일은 <code class=\"language-text\">재배치 가능한 오브젝트 파일(Relocatable object file)</code> 이다. 재배치 가능한 오브젝트 파일은 단일한 하나의 소스코드에 대해서 하나의 파일로 만들어진다. 그리고 여러 소스코드들에서 생성된 이 오브젝트 파일들이 하나로 묶여서 <code class=\"language-text\">실행가능한 오브젝트 파일(Executable object file)</code>이 된다. 이렇게 여러 오브젝트파일을 하나로 모아 실행가능한 파일을 만드는 작업을 <code class=\"language-text\">링킹(Linking)</code> 이라고 한다.</p>\n<h3 id=\"linker-모아모아서-실행파일로-만들자\" style=\"position:relative;\"><a href=\"#linker-%EB%AA%A8%EC%95%84%EB%AA%A8%EC%95%84%EC%84%9C-%EC%8B%A4%ED%96%89%ED%8C%8C%EC%9D%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%9E%90\" aria-label=\"linker 모아모아서 실행파일로 만들자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linker: 모아모아서 실행파일로 만들자</h3>\n<p>링커는 링킹을 하도록 도와주는 역할을 한다. 여러파일에 조각조각 흩어진 변수들이나 함수 등을 하나의 오브젝트 파일로 만들 수 있도록 도와준다. 링킹은 또, 두 가지 경우로 나누어지는데 하나는 <code class=\"language-text\">정적 링킹(Static linking)</code> 다른 하나는 <code class=\"language-text\">동적 링킹(Dynamic Linking)</code> 이라고 한다. 정적 링킹은 우리가 일반적으로 생각하는 그 링킹이다. 실행가능한 오브젝트 파일을 만들면서 각 오브젝트에 포함된 라이브러리의 코드들이 실행파일에 복사된다. 그런데 한정된 컴퓨터 공간 속에서 <code class=\"language-text\">printf()</code> 처럼 매우 빈번하게 여러 프로세스들이 모두 가지고 있는 라이브러리의 함수들의 코드를 실행파일에 담는 것은 엄청난 자원의 낭비이다. 그래서 우리의 척척이 박사님들은 동적 링킹이라는 기법을 고안해낸다.</p>\n<p>동적링킹은 라이브러리가 실행파일에 연결되는 시점을 실행파일이 만들어질 때가 아니라, 이 프로그램이 메모리에 적재되어 실행되는 단계에 이를때까지 연결을 미루는 것이다. 대신 이 라이브러리에 포함된 함수의 원형이나 심볼화된 스니펫을 코드에 끼워넣어서 컴파일 과정에서는 전혀 문제가 없이 컴파일 되도록 한다. <code class=\"language-text\">printf()</code> 와 같은 함수가 포함된 라이브러리는 아마 모든 프로세스가 빠짐없이 다 사용할 것이다. 따라서 이 라이브러리 코드의 사본을 모두에게 각각 주는 것이 아니라, 필요할때만 이 라이브러리를 연결해서 사용하도록 하면, 우리는 좁은 메모리 공간에 하나의 라이브러리를 두는 것 만으로도 여러 프로세스들을 먹여사릴 수 있다. 이렇게 모두에게 동적으로 연결되어 공유되는 라이브러리를 <code class=\"language-text\">동적 연결 라이브러리(Dynamic Linking Library)</code>, 혹은 공유 라이브러리라고 한다.</p>\n<h3 id=\"loader-메모리로-올리자\" style=\"position:relative;\"><a href=\"#loader-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A1%9C-%EC%98%AC%EB%A6%AC%EC%9E%90\" aria-label=\"loader 메모리로 올리자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Loader: 메모리로 올리자</h3>\n<p>링커에 의해 만들어진 실행파일은 이제 디스크에 만들어졌다. 우리가 컴파일 이후에 만나게되는 <code class=\"language-text\">a.out</code> 과 같은 녀석이 바로 이 녀석이다. 그럼 만약 우리가 이 실행파을 실행하게 되면 내부에서는 어떤 일이 일어날까? 이때 로더가 등장한다. 로더는 실행파일을 메모리에 적재시키는 것이 주 임무이다. 메모리에 올라간 파일은 실행과 함께 프로세스가 되고, 스케줄링을 기다리게된다. 컴퓨터 시스템에서 일어나는 모든 작업은 프로세서(CPU)에 의해 진행되는데, 프로세서가 접근할 수 있는 유일한 메모리 공간이 바로 메인메모리이다. 하지만 실행파일은 메인 메모리가 아닌 디스크에 있으니, 이 녀석을 프로세서가 사용할 수 있는 공간으로 넣어주는 것이다.</p>\n<p>이 이후의 과정들은 스케줄러를 통해 CPU를 선점하고 CPU에 의해 프로세스의 명령어들이 실행된다.</p>","frontmatter":{"title":"[운영체제] 소스코드가 빌드되는 과정","date":"June 09, 2020"}}},"pageContext":{"slug":"/Operating-Systems/2020-06-09-운영체제-빌드과정/","previous":{"fields":{"slug":"/Algorithm-Analysis/2020-05-31-알고리즘-Counting-Sort/"},"frontmatter":{"title":"[알고리즘 정리] 계수정렬(Counting Sort)","category":"Algorithm-Analysis","draft":false}},"next":{"fields":{"slug":"/Operating-Systems/2020-06-09-운영체제-메인-메모리-구조/"},"frontmatter":{"title":"[운영체제] 메인 메모리의 구조","category":"Operating-Systems","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}