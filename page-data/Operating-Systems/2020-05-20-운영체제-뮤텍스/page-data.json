{"componentChunkName":"component---src-templates-blog-post-js","path":"/Operating-Systems/2020-05-20-운영체제-뮤텍스/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"f030c05b-9cf0-5c93-86a9-166d38f9097b","excerpt":"참고도서: Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne 뮤텍스(Mutex Lock) 소프트웨어적으로 임계구역 문제를 해결하기 위한 방법 중 하나이다. 임계구역문제를 소프트웨어 단에서 해결하기 위해서는 운영체제를 설계하는 개발자가 알고리즘을 잘 만들어 두어야 하는데, 뮤텍스는 가장 간단하고 단순한 접근방법이다. Concept…","html":"<p>참고도서: <em>Operating System Concepts (10/E) Abraham Silberschatz, Peter B. Galvin, Greg Gagne</em></p>\n<p>뮤텍스(Mutex Lock) 소프트웨어적으로 임계구역 문제를 해결하기 위한 방법 중 하나이다. 임계구역문제를 소프트웨어 단에서 해결하기 위해서는 운영체제를 설계하는 개발자가 알고리즘을 잘 만들어 두어야 하는데, 뮤텍스는 가장 간단하고 단순한 접근방법이다.</p>\n<h2 id=\"concept\" style=\"position:relative;\"><a href=\"#concept\" aria-label=\"concept permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concept</h2>\n<p>뮤텍스는 임계구역 전후로 두 가지 연산을 수행하는 것으로 임계구역 문제를 해결한다.</p>\n<ol>\n<li><code class=\"language-text\">acquire</code> : 임계 구역 내 활동을 요청</li>\n<li><code class=\"language-text\">release</code> : 임계 구역 내 활동을 종료</li>\n</ol>\n<p>쉽게 말해서 어떤 프로세스가 임계 구역 내에서 활동중이라면, 해당 프로세스가 다른 프로세스에게 자신이 임계 구역 내에 있다는 것을 알리는 것이다. 따라서 만약에 다른 프로세스가 임계구역에 진입하려고 할때, 어떤 프로세스가 임계구역 안에 있다면 진입하지 않고 멈추게 되는 것이다.</p>\n<h2 id=\"acquire---임계구역-들어가도-됨\" style=\"position:relative;\"><a href=\"#acquire---%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD-%EB%93%A4%EC%96%B4%EA%B0%80%EB%8F%84-%EB%90%A8\" aria-label=\"acquire   임계구역 들어가도 됨 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>acquire() - 임계구역 들어가도 됨?</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>available<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* busy waiting */</span>\n    available <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">acquire</code> 연산의 구조는 매우 단순하다. 가장 먼저 공유변수는 available 의 상태를 확인한다. 만약 <code class=\"language-text\">available == false</code> 라면, 누군가가 임계 구역안에서 작업을 수행중인 것이다. 따라서 while의 조건이 <code class=\"language-text\">true</code> 가 되어 무한루프에 빠지게 된다.</p>\n<p>반대로 생각해보자, 만약 <code class=\"language-text\">available == true</code> 로 확인되었다면, while문을 곧바로 빠져나와 available을 <code class=\"language-text\">false</code>로 만들고 acquire 함수를 빠져나간다. 이때 다른 프로세스가 임계구역 진입을 위해서 acquire를 수행한다면, 해당 프로세스는 <code class=\"language-text\">available==false</code> 를 확인하게되고, acquire 함수 안에서 무한루프를 돌게 된다.</p>\n<h2 id=\"release---나-끝남\" style=\"position:relative;\"><a href=\"#release---%EB%82%98-%EB%81%9D%EB%82%A8\" aria-label=\"release   나 끝남 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>release() - 나 끝남!</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    available <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">relase</code> 연산의 내부에는 공용변수는 available 을 true 로 만드는 기능 밖에 없다. 어떤 프로세스가 임계구역에서 작업을 바치고 빠져나올 때, <code class=\"language-text\">available</code> 변수를 <code class=\"language-text\">true</code> 로 만든다면, 입계구역에 진입하지 못하고 acquire 의 while 문에서 계속 무한루프에 있던 프로세스가 무한루프를 빠져나와 임계구역에 진입하게 된다.</p>\n<h2 id=\"busy-waiting\" style=\"position:relative;\"><a href=\"#busy-waiting\" aria-label=\"busy waiting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Busy Waiting</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">do</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 나 들어갈거니까 아무도 들어오지마!</span>\n\n    <span class=\"token comment\">/* Critical Section */</span>\n\n    <span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 나 끝났어! 준비됐으면 들어가~~</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 두 연산을 임계구역의 시작과 끝에 위치시키면, 한번에 하나의 프로세스만 임계구역에 진입하는 것을 보장할 수 있게 된다.</p>\n<p>Mutex Lock은 매우 단순하게 임계구역 문제를 해결할 수 있는 기법이지만, 가장 큰 문제는 <code class=\"language-text\">acquire</code> 내부에서 사용하는 <code class=\"language-text\">while(!available)</code> 에 있다. 임계구역 진입을 원하는 프로세스는 다른 프로세스가 임계구역에 있다면, 이곳에서 계속해서 무한회전을 하게되는데, 아무 작업을 하지 않지만 계속 회전하기 때문에 CPU 사이클이 낭비된다는 것이다. 이렇게 아무것도 하지않고 계속 루프를 회전하는 것을 <code class=\"language-text\">Busy Waiting</code>이라고 한다.</p>","frontmatter":{"title":"[운영체제] 뮤텍스(Mutex Lock)","date":"May 20, 2020"}}},"pageContext":{"slug":"/Operating-Systems/2020-05-20-운영체제-뮤텍스/","previous":{"fields":{"slug":"/Operating-Systems/2020-05-20-운영체제-세마포/"},"frontmatter":{"title":"[운영체제] 세마포어(Semaphore)","category":"Operating-Systems","draft":false}},"next":{"fields":{"slug":"/Operating-Systems/2020-05-21-운영체제-식사하는-철학자-문제/"},"frontmatter":{"title":"[운영체제] 고전적 동기화 문제-3 : 식사하는 철학자 문제(The Dining-Philosophers Problem)","category":"Operating-Systems","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}