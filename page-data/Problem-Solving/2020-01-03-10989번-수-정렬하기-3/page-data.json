{"componentChunkName":"component---src-templates-blog-post-js","path":"/Problem-Solving/2020-01-03-10989번-수-정렬하기-3/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"abc830a0-83d1-5fba-b802-6e21ab42dcbc","excerpt":"10989번: 수 정렬하기 3 접근 방법: 접근 방법 1: 문제에서 카운팅 정렬을 사용하라는 힌트를 주어서 구글링을 통해 카운팅 정렬의 개념을 보고 구현에 성공 했다. 근데 메모리 초과 오류가 났다. 이 문제에서 메모리가 8MB로 제한되어 있기 때문에 배열을 3개까지 사용해야하는 카운팅 정렬은 불가능 했다. 접근 방법 2: 자연수가 1000…","html":"<h3 id=\"10989번-수-정렬하기-3\" style=\"position:relative;\"><a href=\"#10989%EB%B2%88-%EC%88%98-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0-3\" aria-label=\"10989번 수 정렬하기 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://www.acmicpc.net/problem/10989\">10989번: 수 정렬하기 3</a></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">문제\nN개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.\n\n입력\n첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.\n\n출력\n첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.</code></pre></div>\n<h3 id=\"접근-방법\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95\" aria-label=\"접근 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방법:</h3>\n<ul>\n<li>접근 방법 1: 문제에서 카운팅 정렬을 사용하라는 힌트를 주어서 구글링을 통해 카운팅 정렬의 개념을 보고 구현에 성공 했다. 근데 메모리 초과 오류가 났다. 이 문제에서 메모리가 8MB로 제한되어 있기 때문에 배열을 3개까지 사용해야하는 카운팅 정렬은 불가능 했다.</li>\n<li>접근 방법 2: 자연수가 10000까지 들어오므로 배열을 하나만 써서 해결해야한다. 카운팅 정렬의 컨셉만 그대로 사용해서 입력을 받을 때마다 입력을 따로 저장하지 않고 몇번 나왔는지 출현 횟수만 저장하는 카운팅 배열 하나만 사용한다. 그리고 입력이 모두 끝난 이후에는 배열의 처음부터 끝까지 순회하면서 숫자 N을 출현했던 횟수 coutn[N] 만큼 출력해준다. 이렇게 하면 배열을 하나만 쓰고 해결 할 수 있다.</li>\n</ul>\n<h3 id=\"통과-코드\" style=\"position:relative;\"><a href=\"#%ED%86%B5%EA%B3%BC-%EC%BD%94%EB%93%9C\" aria-label=\"통과 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통과 코드:</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;vector></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    ios_base<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> N<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> N<span class=\"token punctuation\">;</span>\n\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">outarr</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10001</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 입력을 받을 때마다 배열에 카운팅 개수 늘려주기</span>\n        outarr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 여기 까지 왔을 때는 각 배열의 인덱스에 해당하는 값이 몇번나왔는지 배열에 들어가 있다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> outarr<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>outarr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// 카운팅이 0이 될 때까지 출력</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n            outarr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"[백준 알고리즘] 10989번: 수 정렬하기 3","date":"May 05, 2020"}}},"pageContext":{"slug":"/Problem-Solving/2020-01-03-10989번-수-정렬하기-3/","previous":{"fields":{"slug":"/Problem-Solving/2020-01-05-15650번-N과-M-(2)/"},"frontmatter":{"title":"[백준 알고리즘] 15650번: N과 M (2)","category":"Problem-Solving","draft":false}},"next":{"fields":{"slug":"/Problem-Solving/2020-01-01-1018번-체스판-다시-칠하기/"},"frontmatter":{"title":"[백준 알고리즘] 1018번: 체스판 다시 칠하기","category":"Problem-Solving","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}