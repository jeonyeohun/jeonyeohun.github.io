{"componentChunkName":"component---src-templates-blog-post-js","path":"/Problem-Solving/2020-01-05-15651번-N과-M-(3)/","result":{"data":{"site":{"siteMetadata":{"title":"Hun's Footsteps 🥷","author":"전여훈","siteUrl":"https://jeonyeohun.github.io","comment":{"disqusShortName":"","utterances":"jeonyeohun/jeonyeohun.github.io"},"sponsor":{"buyMeACoffeeId":"jeonyeohun"}}},"markdownRemark":{"id":"5b1a5823-0e45-52a3-aa46-ebadddc3ab34","excerpt":"15651번: N과 M (3) 접근 방법: 기존 N과 M을 구현할 때는 bool형 visited 벡터를 두어서 이미 들렀던 노드의 여부를 체크해줘서 first와 second가 같은 값을 가지지 않도록 했었는데, 이번 문제는 중복을 허용하기 때문에 visited 벡터를 없애고 모든 노드를 매번 순회하면 된다. 통과 코드:","html":"<h3 id=\"15651번-n과-m-3\" style=\"position:relative;\"><a href=\"#15651%EB%B2%88-n%EA%B3%BC-m-3\" aria-label=\"15651번 n과 m 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://www.acmicpc.net/problem/15651\">15651번: N과 M (3)</a></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">문제\n자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.\n - 1부터 N까지 자연수 중에서 M개를 고른 수열\n - 같은 수를 여러 번 골라도 된다.\n\n입력\n첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)\n\n출력\n한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.\n\n수열은 사전 순으로 증가하는 순서로 출력해야 한다.</code></pre></div>\n<h3 id=\"접근-방법\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95\" aria-label=\"접근 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방법:</h3>\n<p>기존 N과 M을 구현할 때는 bool형 visited 벡터를 두어서 이미 들렀던 노드의 여부를 체크해줘서 first와 second가 같은 값을 가지지 않도록 했었는데, 이번 문제는 중복을 허용하기 때문에 visited 벡터를 없애고 모든 노드를 매번 순회하면 된다.</p>\n<h3 id=\"통과-코드\" style=\"position:relative;\"><a href=\"#%ED%86%B5%EA%B3%BC-%EC%BD%94%EB%93%9C\" aria-label=\"통과 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통과 코드:</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;vector></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> N<span class=\"token punctuation\">,</span> M<span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">numbers</span> <span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">DFS</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> cnt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cnt <span class=\"token operator\">==</span> M<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> M <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> numbers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 원래 자기자신은 건너뛰려고 visited 벡터를 만들어서 이미 들렀던 노드인지 확인하는 작업을 거쳤는데, 이 문제는 중복이 허용되기 때문에 그냥 매번 전부 다 순회하면 된다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> N <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        numbers<span class=\"token punctuation\">[</span>cnt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">DFS</span><span class=\"token punctuation\">(</span>cnt<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    cin <span class=\"token operator\">>></span> N <span class=\"token operator\">>></span> M<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">DFS</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"[백준 알고리즘] 15651번: N과 M (3)","date":"May 05, 2020"}}},"pageContext":{"slug":"/Problem-Solving/2020-01-05-15651번-N과-M-(3)/","previous":{"fields":{"slug":"/Problem-Solving/2020-01-07-15654번-N과-M-(5)/"},"frontmatter":{"title":"[백준 알고리즘] 15654번: N과 M (5)","category":"Problem-Solving","draft":false}},"next":{"fields":{"slug":"/Problem-Solving/2020-01-07-10867번-중복-빼고-정렬하기/"},"frontmatter":{"title":"[백준 알고리즘] 10867번: 중복 빼고 정렬하기","category":"Problem-Solving","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}